---
title: "Data Wrangling and Statistical Analysis of Assessment of Abundance, Aggregation, and Web Placement of *Agelenopsis pennsylvanica*"
author: "Brandi Pessman"
date: "`r Sys.Date()`"
output: html_document
---

## Setting the Working Directory and Global Code Chunk Options

Using include = FALSE means that this chunk will run, but the code and the results will not appear in the knitted document. We have set message and warning to FALSE for every chunk so the knitted document is not bombarded with messages and warnings. 

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
require("knitr")
opts_knit$set(root.dir = "/Users/bjpessman/Documents/phd_research_code/Agelenopsis_aggregation")
```

## Packages to Load

There is a brief explanation of each package's purpose left as a comment following the library call. 

```{r packages, include = FALSE}
library(tidyverse) # to use pipelines in data wrangling
library(ggpubr) # using ggarrange to make multi-panel figures
library(caret) # used to find correlations between predictor variables
library(PerformanceAnalytics) # used to make correlation plots
library(broom) # allows us to use augment when getting predicted values from the model
library(emmeans) # for calculating predictions for graphing
library(pander) # viewing AIC comparisons between models
library(AICcmodavg) # also helps viewing AIC comparisons
library(MuMIn) # to run the dredge function
```

## Import Data

The document "webs" is a text file in the data folder of the repository/directory. 

```{r import, include = FALSE}
webs <- read.table(file = "data/webs.txt", header = TRUE) 
# includes data for every measured web (multiple per site)
```

## Data Wrangling

Here, we rename some levels of factors Location and Land and put them in the order we want the categories to appear in a graph. We also create another data set "sites" that restricts "webs" to just a single data point for each site. We use "sites" to compare search distance, the number of webs, and the number of spiders. We will use "webs" for web height and nearest neighbor analyses. 

```{r webs_wrangling, include = FALSE}
webs <- webs %>% 
  mutate(ID = factor(ID),
         Location = factor(Location),
         Location = fct_recode(Location, 
                               "Urban Forest" = "Forest",
                               "Urban Center" = "Campus"),
         Location = fct_relevel(Location, 
                                "Urban Forest", "Urban Center"),
         Land = fct_recode(Land, 
                           "Urban, High" = "UrbanizedHighIntensity",
                           "Urban, Medium" = "UrbanizedMediumIntensity",
                           "Urban, Low" = "UrbanizedLowIntensity",
                           "Deciduous Forest" = "DeciduousForest",
                           "Woody Wetlands" = "WoodyWetlands"),
         Land = fct_relevel(Land, 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low", 
                            "Deciduous Forest", 
                            "Woody Wetlands"),
         patch_area_km = patch_area_mm * 1e-6) %>% 
  dplyr::rename("Impervious" = "Imperv", 
                "Dist_to_Road" = "road_dist_data", 
                "Traffic_Dist_Road" = "dist_traffic_road", 
                "Dist_to_Highway" = "highway_dist_m", 
                "Traffic_Dist_Highway" = "dist_traffic_highway")

sites <- webs %>% 
  filter(Web == "W001") 
```

At one time, we tried scaling and centering the data in difference ways. I want to make mention of it here because it might be useful information for me to look back on in the future. Scaling is dividing each datum by the standard deviation of the data and centering is subtracting the mean of the data from each datum to try to normalize the data; a second type of centering and scaling involves subtracting the median and dividing by the interquartile range; need to remember to back transform when making figures; we didn't scale and center because log-transformations on zero-inflated variables were enough to remove convergence errors

```{r sites_wrangling, include = FALSE}
sites <- sites %>% 
  mutate(patch_area_km = patch_area_mm * 1e-6)
```

## Transformation of Variables

Many data are zero-inflated or right skewed. We check the distribution of the data and check distributions after log-transformation for right-skewed data not containing zeros. Echo = FALSE shows the results, but does not show the code used. 

```{r graphing_predictor_distributions, echo = FALSE}
# Here, we graph the distribution of predictor variables in their raw distribution and after log-transformation since all variables are positive values, and many are zero-inflated; we also run shapiro-wilk tests to test for normality including the log-transformed variable if the log-transformed distribution looks better (less skewed)

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = tree100m)) +
  geom_density()
shapiro.test(sites$tree100m) # not normal

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = imperv100m)) +
  geom_density()
shapiro.test(sites$imperv100m) # not normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = TotalSub)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(TotalSub))) +
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$TotalSub) # not normal
shapiro.test(log(sites$TotalSub)) # normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = Traffic_Dist_Road)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(Traffic_Dist_Road))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$Traffic_Dist_Road) # not normal
shapiro.test(log(sites$Traffic_Dist_Road)) # normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = Traffic_Dist_Highway)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(Traffic_Dist_Highway))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$Traffic_Dist_Highway) # not normal
shapiro.test(log(sites$Traffic_Dist_Highway)) # almost normal

# looks similar either way
ggarrange(ggplot(sites, aes(x = spec_rad)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(spec_rad))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$spec_rad) # not normal
shapiro.test(log(sites$spec_rad)) # not normal

# looks similar either way, but shapiro tests suggests as is is slightly better
ggarrange(ggplot(sites, aes(x = light_rad)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(light_rad))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$light_rad) # not normal
shapiro.test(log(sites$light_rad)) # not normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = patch_area_mm)) +
            geom_density(), 
          ggplot(sites, aes(x = log(patch_area_mm))) +
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$patch_area_mm) # not normal
shapiro.test(log(sites$patch_area_mm)) # almost normal

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = road_length_m)) + 
  geom_density()
shapiro.test(sites$road_length_m) # not normal

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = trail_length_m)) + 
  geom_density()
shapiro.test(sites$trail_length_m) # not normal

sites <- sites %>% 
  mutate(log_TotalSub = log(TotalSub),
         log_tdr = log(Traffic_Dist_Road),
         log_tdh = log(Traffic_Dist_Highway),
         log_patch = log(patch_area_km))

webs <- webs %>% 
  mutate(log_TotalSub = log(TotalSub),
         log_tdr = log(Traffic_Dist_Road),
         log_tdh = log(Traffic_Dist_Highway),
         log_patch = log(patch_area_mm))

sites <- webs %>% 
  filter(Web == "W001") 
```

We conclude to use log-transformations for TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, and patch_area_km.

Our analyses include looking at variation within each location. As such, this chunk subsets the "sites" and "webs" data by Location.

```{r location_subsets, include  = FALSE}
webs_center <- webs %>% 
  filter(Location == "Urban Center")

webs_forest <- webs %>% 
  filter(Location == "Urban Forest")

sites_center <- sites %>% 
  filter(Location == "Urban Center")

sites_forest <- sites %>% 
  filter(Location == "Urban Forest")
```

## Variable Reduction Based on Correlations

Since many of these variables are likely highly correlated, we want to reduce the variables that we include in our model by removing variables that are highly correlated.

```{r correlations_overall}
corr <- sites %>% 
  select(tree100m, imperv100m, TotalSub, 
         Traffic_Dist_Road, Traffic_Dist_Highway, 
         spec_rad, light_rad, patch_area_mm, road_length_m)
# We exclude trail length from global correlations because trail length can only collected in Wilderness Park, and not for UNL City Campus

# When running findCorrelations, we get a vector of variables to remove to reduce pairwise correlations. 

findCorrelation(cor(corr, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 

# This suggests that we remove tree100m, imperv100, spec_rad, light_rad, patch_area_km, road_length_m
# That leaves us with TotalSub, Traffic_Dist_Road, and Traffic_Dist_Highway

chart.Correlation(corr, histogram = TRUE, method = "spearman") # kendall, spearman

corr <- sites %>% 
  select(TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway)
chart.Correlation(corr, histogram = TRUE, method = "spearman") # kendall, spearman

# Let's also test the variables after transformation

corr_transformed <- sites %>% 
  select(tree100m, imperv100m, log_TotalSub, 
         log_tdr, log_tdh, 
         spec_rad, light_rad, log_patch, road_length_m)

findCorrelation(cor(corr_transformed, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 

# This suggests to remove tree100m, imperv100m, spec_rad, light_rad, log_patch, and road_length_m.

# This leaves us with log_TotalSub, log_tdr, and log_tdh, the same results as the non-transformed. 

chart.Correlation(corr_transformed, histogram = TRUE, method = "spearman") # kendall, spearman

corr_transformed <- sites %>% 
  select(log_TotalSub, log_tdr, log_tdh)
chart.Correlation(corr_transformed, histogram = TRUE, method = "spearman") # kendall, spearman
```

```{r correlations_forest}
corr_forest <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  select(tree100m, imperv100m, TotalSub, 
         Traffic_Dist_Road, Traffic_Dist_Highway, 
         spec_rad, light_rad, patch_area_km, road_length_m, trail_length_m)
# Notice trail length is included 

findCorrelation(cor(corr_forest, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
# This suggests removing imperv100m, spec_rad, light_rad, road_length_m, and trail_length_m
# We will keep tree100m, TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, and patch_area_km
chart.Correlation(corr_forest, histogram = TRUE, method = "spearman")
corr_forest <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  select(tree100m, TotalSub, Traffic_Dist_Road, patch_area_km, Traffic_Dist_Highway)
chart.Correlation(corr_forest, histogram = TRUE, method = "spearman")

# Let's try with the log-transformed
corr_forest_transformed <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  select(tree100m, imperv100m, log_TotalSub, 
         log_tdr, log_tdh, 
         spec_rad, light_rad, log_patch, road_length_m, trail_length_m)

findCorrelation(cor(corr_forest_transformed, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
# The same variables are dropped and kept

corr_forest_transformed <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  select(tree100m, log_TotalSub, log_tdr, patch_area_km, log_tdh)
chart.Correlation(corr_forest_transformed, histogram = TRUE, method = "spearman")
```

```{r correlations_center}
corr_center <- sites %>% 
  filter(Location == "Urban Center") %>% 
  select(tree100m, imperv100m, TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, spec_rad, light_rad, patch_area_km, road_length_m)
# Trail length is removed because we could not measure trail length on campus

findCorrelation(cor(corr_center, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
# This suggests that we remove tree100m, imperv100m, and light_rad
# We will keep TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, spec_rad, patch_area_km, and road_length_m

chart.Correlation(corr_center, histogram = TRUE, method = "spearman")

# Let's try with the transformed
corr_center_transformed <- sites %>% 
  filter(Location == "Urban Center") %>% 
  select(tree100m, imperv100m, log_TotalSub, log_tdr, log_tdh, spec_rad, light_rad, log_patch, road_length_m)
findCorrelation(cor(corr_center_transformed, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
chart.Correlation(corr_center_transformed, histogram = TRUE, method = "pearson")
# The same variables are kept or removed
```

For overall analysis of predictors, we will include: 

- log_TotalSub

- log_tdr

- log_tdh

For the urban forest subset, we will use: 

- tree100m 

- log_TotalSub 

- log_tdr 

- log_tdh

- log_patch

Finally, for the urban center subset, we will use: 

- log_TotalSub 

- log_tdr 

- log_tdh 

- spec_rad

- log_patch

- road_length_m

## Graphs, Stats, and Assumptions Comparing Predictors by Location

Here, we just want to see if each predictor differs between the two Locations: urban forest and urban center. We build models, check assumptions of the model, and make graphs to represent differences. 

```{r stats_graphs_tree, echo = FALSE}
tree100m <- glm(tree100m ~ Location, family = "poisson", data = sites)
summary(tree100m)

# The following line tells you the mean and standard error of the raw data for tree cover in a 100 m radius of the sites between the two locations
sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(tree100m),
            se = plotrix::std.error(tree100m))

predictions <- summary(emmeans(tree100m, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = tree100m)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 100), breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)) +
  theme_classic() +
  ylab("Percent Tree Cover \n[100m radius]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=100, label="***", color="black", size = 10)
```

```{r tree_assumptions, echo = FALSE}
test_tree <- augment(tree100m, data = sites)
resid_tree <- ggplot(test_tree, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_tree$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_tree <- ggplot(test_tree, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_tree, qq_tree, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Tree cover is *significantly higher in the urban forest* than the urban center (z = -14.50, df = 1, 20, p < 0.001). The means and SE's are 47.15 ± 2.17 % for the urban forest and 1.58 ± 0.36 % for the urban center. 

```{r stats_graphs_imperv, echo = FALSE}
imperv100m <- glm(imperv100m ~ Location, family = "poisson", data = sites)
summary(imperv100m)

# The following line tells you the mean and standard error of the raw data for impervious cover in a 100 m radius of the sites between the two locations
sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(imperv100m),
            se = plotrix::std.error(imperv100m))

predictions <- summary(emmeans(imperv100m, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = imperv100m)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 100), breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)) +
  theme_classic() +
  ylab("Percent Impervious Cover \n[100m radius]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=100, label="***", color="black", size = 10)
```

```{r imperv_assumptions, echo = FALSE}
test_imperv <- augment(imperv100m, data = sites)
resid_imperv <- ggplot(test_imperv, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_imperv$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_imperv <- ggplot(test_imperv, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_imperv, qq_imperv, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Impervious cover is *significantly higher in the urban center* than the urban forest (z = 14.51, df = 1, 20, p < 0.001). The means and SE's are 1.27 ± 0.36 % for the urban forest and 76.52 ± 2.53 % for the urban center. 

```{r stats_graphs_tdr, echo = FALSE}
tdr <- glm(log_tdr ~ Location, family = "poisson", data = sites)
summary(tdr)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_tdr),
            se = plotrix::std.error(log_tdr))

predictions <- summary(emmeans(tdr, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = exp(log_tdr))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 1400), breaks = c(0, 200, 400, 600, 800, 1000, 1200, 1400)) +
  theme_classic() +
  ylab("Road Disturbance \n[vehicles/day/m]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=1400, label="", color="black", size = 10)
```

```{r tdr_assumptions, echo = FALSE}
test_tdr <- augment(tdr, data = sites)
resid_tdr <- ggplot(test_tdr, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_tdr$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_tdr <- ggplot(test_tdr, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_tdr, qq_tdr, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

There is *no difference* in road disturbance between the urban forest and urban center (z = 1.403, df = 1, 20, p = 0.161). The means and SE's are 52.98 ± 1.88 vehicles/day/m for the urban forest and 194.42 ± 1.93 vehicles/day/m for the urban center. 

```{r stats_graphs_tdh, echo = FALSE}
tdh <- glm(log_tdh ~ Location, family = "poisson", data = sites)
summary(tdh)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_tdh),
            se = plotrix::std.error(log_tdh))

predictions <- summary(emmeans(tdh, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = exp(log_tdh))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 250), breaks = c(0, 50, 100, 150, 200, 250)) +
  theme_classic() +
  ylab("Highway Disturbance \n[vehicles/day/m]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=250, label="", color="black", size = 10)
```

```{r tdh_assumptions, echo = FALSE}
test_tdh <- augment(tdh, data = sites)
resid_tdh <- ggplot(test_tdh, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_tdh$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_tdh <- ggplot(test_tdh, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_tdh, qq_tdh, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

There is *no difference* in highway disturbance between the urban forest and urban center (z = 0.530, df = 1, 20, p = 0.596). The means and SE's are 33.78 ± 1.80 vehicles/day/m for the urban forest and 52.46 ± 1.77 vehicles/day/m for the urban center. 

```{r stats_graphs_plant, echo = FALSE}
plant <- glm(log_TotalSub ~ Location, family = "poisson", data = sites)
summary(plant)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_TotalSub),
            se = plotrix::std.error(log_TotalSub))

predictions <- summary(emmeans(plant, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = exp(log_TotalSub))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 25), breaks = c(0, 5, 10, 15, 20, 25)) +
  theme_classic() +
  ylab("Plant Species Richness \n[species/site]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=25, label="*", color="black", size = 10)
```

```{r plant_assumptions, echo = FALSE}
test_plant <- augment(plant, data = sites)
resid_plant <- ggplot(test_plant, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_plant$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_plant <- ggplot(test_plant, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_plant, qq_plant, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Plant species richness is *significantly higher in the urban forest* than the urban center (z = -2.430, df = 1, 20, p = 0.015). The means and SE's are 12.18 ± 1.65 species for the urban forest and 2.97 ± 1.35 species for the urban center. 

```{r stats_graphs_spec, echo = FALSE}
spec <- glm(spec_rad ~ Location, family = "poisson", data = sites)
summary(spec)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(spec_rad),
            se = plotrix::std.error(spec_rad))

predictions <- summary(emmeans(spec, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = spec_rad)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(130, 165), breaks = c(130, 135, 140, 145, 150, 155, 160, 165)) +
  theme_classic() +
  ylab("Spectral Radiance \n[Watts/(m² * sr * µm)]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=165, label="**", color="black", size = 10)
```

```{r spec_assumptions, echo = FALSE}
test_spec <- augment(plant, data = sites)
resid_spec <- ggplot(test_spec, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_spec$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_spec <- ggplot(test_spec, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_spec, qq_spec, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Spectral radiance is *significantly higher in the urban center* than the urban forest (z = 3.079, df = 1, 20, p = 0.002). The means and SE's are 137.44 ± 3.71 Watts/(m² * sr * µm) for the urban forest and 153.39 ± 3.58 Watts/(m² * sr * µm) for the urban center. 

```{r stats_graphs_light, echo = FALSE}
light <- glm(light_rad ~ Location, family = "poisson", data = sites)
summary(light)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(light_rad),
            se = plotrix::std.error(light_rad))

predictions <- summary(emmeans(light, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = light_rad)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 175), breaks = c(0, 25, 50, 75, 100, 125, 150, 175)) +
  theme_classic() +
  ylab("Radiance [mcd/m²]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=175, label="***", color="black", size = 10)
```

```{r light_assumptions, echo = FALSE}
test_light <- augment(plant, data = sites)
resid_light <- ggplot(test_light, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_light$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_light <- ggplot(test_light, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_light, qq_light, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Light radiance is *significantly higher in the urban center* than the urban forest (z = 22.46, df = 1, 20, p < 0.001). The means and SE's are 5.89 ± 0.77 mcd/m² for the urban forest and 116.90 ± 3.12 mcd/m² for the urban center.

```{r stats_graphs_patch, echo = FALSE}
patch <- glm(log_patch ~ Location, family = "poisson", data = sites)
summary(patch)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_patch),
            se = plotrix::std.error(log_patch))

predictions <- summary(emmeans(patch, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = exp(log_patch))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 130310), breaks = c(0, 20000, 40000, 60000, 80000, 100000, 120000)) +
  theme_classic() +
  ylab("Patch Area [mm²]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=130310, label="***", color="black", size = 10)
```

```{r patch_assumptions, echo = FALSE}
test_patch <- augment(patch, data = sites)
resid_patch <- ggplot(test_patch, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_patch$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_patch <- ggplot(test_patch, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_patch, qq_patch, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Patch area is *significantly higher in the urban forest* than the urban center (z = -3.599, df = 1, 20, p < 0.001). The means and SE's are 37,049.12 ± 2.80 mm^2 for the urban forest and 437.03 ± 2.03 mm^2 for the urban center. 

```{r stats_graphs_road, echo = FALSE}
road <- glm(road_length_m ~ Location, family = "poisson", data = sites)
summary(road)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(road_length_m),
            se = plotrix::std.error(road_length_m))

predictions <- summary(emmeans(road, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = road_length_m)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 140), breaks = c(0, 20, 40, 60, 80, 100, 120, 140)) +
  theme_classic() +
  ylab("Total Length of Road \n[m, 100m radius]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=140, label="***", color="black", size = 10)
```

```{r road_assumptions, echo = FALSE}
test_road <- augment(road, data = sites)
resid_road <- ggplot(test_road, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_road$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_road <- ggplot(test_road, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_road, qq_road, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Total road length is *significantly higher in the urban center* than the urban forest (z = 20.89, df = 1, 20, p < 0.001). The means and SE's are 15.67 ± 1.25 m for the urban forest and 93.03 ± 2.78 m for the urban center. 

## Response Variable: Search Distance

### Search Distance by Location

```{r search_location_stats}
ggarrange(ggplot(sites, aes(x = WalkDist)) +
            geom_density(),
          ggplot(sites, aes(x = log(WalkDist))) +
            geom_density(), ncol = 2)

shapiro.test(sites$WalkDist) # not normal
shapiro.test(log(sites$WalkDist)) # normal

search <- glm(WalkDist ~ Location, data = sites, family = poisson)
summary(search)

search2 <- glm(log(WalkDist) ~ Location, data = sites)
summary(search2)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(WalkDist),
            se = plotrix::std.error(WalkDist))
```

```{r search_location_assumptions, echo = FALSE}
# As is, Poisson
test_search <- augment(search, data = sites)
resid_search <- ggplot(test_search, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_search$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_search <- ggplot(test_search, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_search, qq_search, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)

# Log-transformed, Normal
test_search2 <- augment(search2, data = sites)
resid_search2 <- ggplot(test_search2, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_search2$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_search2 <- ggplot(test_search2, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_search2, qq_search2, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

```{r search_location_graph, echo = FALSE}
# Non-transformed, poisson distribution
predictions <- summary(emmeans(search, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = WalkDist)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
  scale_y_continuous(limits = c(0, 275), breaks = c(0, 50, 100, 150, 200, 250)) +
  ylab("Search Distance [m]") + 
  theme(text = element_text(size = 16)) + 
  theme(axis.text.x = element_text(colour = "black", size = 16)) + 
  theme(axis.text.y = element_text(colour = "black", size = 16),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 275, label = "***", color = "black", size = 10)

# Let's look at the log-transformed response variable since that is normal
predictions2 <- summary(emmeans(search2, ~Location),type = "response")

ggplot(sites, aes(x = Location, y = (WalkDist))) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = response, color = Location), size = 2, data = predictions2) + 
  geom_errorbar(aes(x = Location, 
                  ymin = response - SE, 
                  ymax = response + SE,
                  color = Location), data = predictions2, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
  scale_y_continuous(limits = c(0, 275), breaks = c(0, 50, 100, 150, 200, 250)) +
  ylab("Search Distance [m]") + 
  theme(text = element_text(size = 16)) + 
  theme(axis.text.x = element_text(colour = "black", size = 16)) + 
  theme(axis.text.y = element_text(colour = "black", size = 16),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 275, label = "***", color = "black", size = 10)
```

### Search Distance by Predictors

```{r search_predictors_stats}
# This is one way to look at the overall data, but I think I end up not using this information
models = list(WalkDist ~ 1,
              WalkDist ~ log_TotalSub, 
              WalkDist ~ log_tdr, 
              WalkDist ~ log_tdh,
              WalkDist ~ log_TotalSub + log_tdr,
              WalkDist ~ log_TotalSub + log_tdh,
              WalkDist ~ log_tdr + log_tdh,
              WalkDist ~ log_TotalSub + log_tdr + log_tdh)
fits = lapply(models, glm, data = sites, family = "poisson")
modnames = sapply(models, function(ff)deparse(ff[[3]]))
pander(aictab(fits, modname = modnames), caption="Table 1. AICc model selection table for Search Distance to the Focal Web Overall.", split.tables = Inf)
# The top model keeps all 3 variables and no other model is within 2 Model Likelihood Units
summary(glm(WalkDist ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson))


global <- glm(WalkDist ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = F, evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wd_o <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wd_o)
info <- out[[12]]
#TotalSub (log_TotalSub)
exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Road (log_tdr)
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Highway (log_tdh)
exp(info[2, 1])
exp(info[2, 2])

with(summary(top_model_wd_o), 1 - deviance/null.deviance) # This gives the R squared value
#summary(model.avg(model_dredge, subset = delta <= 2))
#summary(model.avg(model_dredge))
model.sel(model_dredge) #estimates same signs
car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban forest
global <- glm(WalkDist ~ tree100m + log_TotalSub + log_tdh + log_patch + log_tdr, data = sites_forest, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = F, evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wd_f <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wd_f)
info <- out[[12]]
#tree100m
info[5, 1]
info[5, 2]
#TotalSub
-exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Road
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Highway
exp(info[2, 1])
exp(info[2, 2])
with(summary(top_model_wd_f), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban center
global <- glm(WalkDist ~ log_TotalSub + log_tdr + log_tdh + spec_rad + log_patch + road_length_m, data = sites_center, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = F, evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wd_c <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wd_c)
info <- out[[12]]
#TotalSub
exp(info[5, 1])
exp(info[5, 2])
#patch_area_km
exp(info[2, 1])
exp(info[2, 2])
#spec_rad
info[6, 1]
info[6, 2]
#Traffic_Dist_Road
exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Highway
exp(info[3, 1])
exp(info[3, 2])
with(summary(top_model_wd_c), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 1)[[1]]) # road and highway disturbance between 2 and 3
```

*Overall*
Coefficients:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)   2.45699    0.24451  10.049  < 2e-16 ***
log_tdh       0.21434    0.04469   4.796 1.62e-06 *** *positive*
log_tdr       0.13279    0.01775   7.480 7.42e-14 *** *positive*
log_TotalSub  0.31671    0.03252   9.740  < 2e-16 *** *positive*

R-squared = 0.0821148

*Urban Forest*
Coefficients:
              Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -2.962190   0.608574  -4.867 1.13e-06 ***
log_tdh       1.354582   0.109952  12.320  < 2e-16 *** *positive*
log_tdr       0.718623   0.038386  18.721  < 2e-16 *** *positive*
log_TotalSub -1.010040   0.095179 -10.612  < 2e-16 *** *negative*
tree100m      0.049914   0.004241  11.770  < 2e-16 *** *positive*

R-squared = 0.5328974

*Urban Center*
Coefficients:
              Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -26.90656    2.78649  -9.656  < 2e-16 ***
log_patch      1.05254    0.05903  17.832  < 2e-16 *** *positive* 
log_tdh        0.58001    0.09128   6.354 2.10e-10 *** *positive*
log_tdr        0.45331    0.04386  10.335  < 2e-16 *** *positive*
log_TotalSub   0.54581    0.08135   6.709 1.96e-11 *** *positive*
spec_rad       0.12466    0.01458   8.549  < 2e-16 *** *positive*

R-squared = 0.9399876

```{r search_predictors_overall_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 3.2, 0.03), 
                 log_tdr = mean(sites$log_tdr), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_wd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
search_plant <- ggplot(sites, aes(x = log_TotalSub, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$WalkDist)), max(log(sites$WalkDist)) + 0.1 * diff(range(log(sites$WalkDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(sites$WalkDist)), label = "***", color = "black", size = 4)

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdr = seq(2.7, 7.3, 0.05), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_wd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
search_tdr <- ggplot(sites, aes(x = log_tdr, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$WalkDist)), max(log(sites$WalkDist)) + 0.1 * diff(range(log(sites$WalkDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites$WalkDist)), label = "***", color = "black", size = 4)

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdr = mean(sites$log_tdr), 
                 log_tdh = seq(2.7, 5.5, 0.03))
predicted.distance <- augment(top_model_wd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
search_tdh <- ggplot(sites, aes(x = log_tdh, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$WalkDist)), max(log(sites$WalkDist)) + 0.1 * diff(range(log(sites$WalkDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites$WalkDist)), label = "***", color = "black", size = 4)

search_plant
search_tdr
search_tdh
```

```{r search_predictors_forest_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Tree
nd <- data.frame(tree100m = seq(31, 66, 0.3),
                 log_TotalSub = mean(sites_forest$log_TotalSub), 
                 log_tdr = mean(sites_forest$log_tdr), 
                 log_tdh = mean(sites_forest$log_tdh))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_tree <- ggplot(sites_forest, aes(x = log(tree100m), y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log(tree100m), y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log(tree100m), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.1 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Percent Tree Cover [log(%)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(log(predicted.distance$tree100m)) + diff(range(log(predicted.distance$tree100m)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)

# TotalSub
nd <- data.frame(tree100m = mean(sites_forest$tree100m),
                 log_TotalSub = seq(1.94, 3.14, 0.01), 
                 log_tdr = mean(sites_forest$log_tdr), 
                 log_tdh = mean(sites_forest$log_tdh))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_plant <- ggplot(sites_forest, aes(x = log_TotalSub, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.1 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_TotalSub)) + diff(range((predicted.distance$log_TotalSub)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)  

# Road Disturbance
nd <- data.frame(tree100m = mean(sites_forest$tree100m),
                 log_TotalSub = mean(sites_forest$log_TotalSub), 
                 log_tdr = seq(2.73, 6.22, 0.03), 
                 log_tdh = mean(sites_forest$log_tdh))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_tdr <- ggplot(sites_forest, aes(x = log_tdr, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.15 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)  

# Highway Disturbance
nd <- data.frame(tree100m = mean(sites_forest$tree100m),
                 log_TotalSub = mean(sites_forest$log_TotalSub), 
                 log_tdr = mean(sites_forest$log_tdr), 
                 log_tdh = seq(2.76, 3.89, 0.01))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_tdh <- ggplot(sites_forest, aes(x = log_tdh, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.1 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)

search_forest_tree
search_forest_plant
search_forest_tdr
search_forest_tdh
```

```{r search_predictors_center_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 1.8, 0.02), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_plant <- ggplot(sites_center, aes(x = log_TotalSub, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_TotalSub)) + diff(range((predicted.distance$log_TotalSub)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Patch Area
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = seq(4.34, 7.52, 0.03),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_patch <- ggplot(sites_center, aes(x = log_patch, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_patch, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_patch, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)) - 0.75, max(log(sites_center$WalkDist)) + 0.15 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Patch Area [log(mm²)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_patch)) + diff(range((predicted.distance$log_patch)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Spectral Radiance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = seq(144.36, 162.87, 0.1),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_spec <- ggplot(sites_center, aes(x = log(spec_rad), y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log(spec_rad), y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log(spec_rad), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Spectral Radiance [log(Watts/(m² * sr * µm))]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(log(predicted.distance$spec_rad)) + diff(range(log(predicted.distance$spec_rad)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = seq(3.00, 7.22, 0.04), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
ggplot(sites_center, aes(x = log_tdr, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = seq(3.32, 5.42, 0.02))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_tdh <- ggplot(sites_center, aes(x = log_tdh, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

search_center_plant
search_center_patch
search_center_spec
search_center_tdr
search_center_tdh
```

### Search Distance by Land

```{r search_land_stats}
search_land <- glm(WalkDist ~ Land, data = sites, family = poisson)
summary(search_land)
anova(search_land, test = "Chisq")
comp <- glht(search_land, linfct = mcp(Land = "Tukey"))
summary(comp)
```

```{r search_land_graph}
sites <- sites %>% 
  mutate(Land = fct_relevel(Land, "Deciduous Forest", 
                            "Woody Wetlands", 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low"))
predictions <- summary(emmeans(search_land, ~Land),type = "response")

ggplot(sites, aes(x = Land, y = WalkDist)) + 
  geom_jitter(color = "grey", width = 0.1, size = 0.5) +
  geom_point(aes(x = Land, y = rate, color = Land), size = 1, data = predictions) + 
  geom_errorbar(aes(x = Land, 
                  ymin = rate - SE, 
                  ymax = rate + SE, color = Land), data = predictions, inherit.aes = FALSE, width = 0.25, size = 1) +
  theme_classic() +
  scale_color_manual(values = c("Deciduous Forest" = "#1b9e77", "Woody Wetlands" = "#1b9e77", "Urban, High" = "#d95f02", "Urban, Medium" = "#d95f02", "Urban, Low" = "#d95f02")) +
  xlab("Land Cover Class") +
  ylab("Search Distance [m]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) +
  annotate(geom="text", x=1, y=max(sites$WalkDist), label="A", color="black", size = 3) +
  annotate(geom="text", x=2, y=max(sites$WalkDist), label="B", color="black", size = 3) +
  annotate(geom="text", x=3, y=max(sites$WalkDist), label="C", color="black", size = 3) +
  annotate(geom="text", x=4, y=max(sites$WalkDist), label="A", color="black", size = 3) +
  annotate(geom="text", x=5, y=max(sites$WalkDist), label="A", color="black", size = 3)
```

## Response Variable: Number of Webs

### Number of Webs by Location

### Number of Webs by Predictors

### Number of Webs by Land
