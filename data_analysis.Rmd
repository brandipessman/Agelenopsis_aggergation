---
title: "Data Wrangling and Statistical Analysis of Assessment of Abundance, Aggregation, and Web Placement of *Agelenopsis pennsylvanica*"
author: "Brandi Pessman"
date: "`r Sys.Date()`"
output: html_document
---

## Setting the Working Directory and Global Code Chunk Options

Using include = FALSE means that this chunk will run, but the code and the results will not appear in the knitted document. We have set message and warning to FALSE for every chunk so the knitted document is not bombarded with messages and warnings. 

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
require("knitr")
opts_knit$set(root.dir = "/Users/bjpessman/Documents/phd_research_code/Agelenopsis_aggregation")
```

## Packages to Load

There is a brief explanation of each package's purpose left as a comment following the library call. 

```{r packages, include = FALSE}
library(tidyverse) # to use pipelines in data wrangling
library(ggpubr) # using ggarrange to make multi-panel figures
library(caret) # used to find correlations between predictor variables
library(PerformanceAnalytics) # used to make correlation plots
library(broom) # allows us to use augment when getting predicted values from the model
library(emmeans) # for calculating predictions for graphing
library(pander) # viewing AIC comparisons between models
library(AICcmodavg) # also helps viewing AIC comparisons
library(MuMIn) # to run the dredge function
library(lme4) # to run the glmer function for the web distance (random effects)
library(broom.mixed) # for augment of the mixed effect models (web distance) to look at assumptions
library(multcomp) # for pairwise comparisons of land cover categories
library(flextable) # making tables
```

## Import Data

The document "webs" is a text file in the data folder of the repository/directory. 

```{r import, include = FALSE}
webs <- read.table(file = "data/webs.txt", header = TRUE) 
# includes data for every measured web (multiple per site)
land_cover <- read.table(file = "data/land_cover_table.txt", header = TRUE) # for land cover table
pred_table <- read.table(file = "data/pred_table.txt", header = TRUE) # for predictor stats table
substrates <- read.table(file = "data/substrate.txt", header = TRUE) # for substrate figure
site_info <- read.table(file = "data/site_info.txt", header = TRUE) # for site information table
pred_table_avg <- read.table(file = "data/pred_table_avg.txt", header = TRUE) # for predictor stats table
```

## Data Wrangling

Here, we rename some levels of factors Location and Land and put them in the order we want the categories to appear in a graph. We also create another data set "sites" that restricts "webs" to just a single data point for each site. We use "sites" to compare search distance, the number of webs, and the number of spiders. We will use "webs" for web height. The "web_dist" data set is a subset of "webs" that looks at the distance from the focal web to the nearest and second nearest neighbors. 

```{r webs_wrangling, include = FALSE}
webs <- webs %>% 
  mutate(ID = factor(ID),
         Location = factor(Location),
         Location = fct_recode(Location, 
                               "Urban Forest" = "Forest",
                               "Urban Center" = "Campus"),
         Location = fct_relevel(Location, 
                                "Urban Forest", "Urban Center"),
         Land = fct_recode(Land, 
                           "Urban, High" = "UrbanizedHighIntensity",
                           "Urban, Medium" = "UrbanizedMediumIntensity",
                           "Urban, Low" = "UrbanizedLowIntensity",
                           "Deciduous Forest" = "DeciduousForest",
                           "Woody Wetlands" = "WoodyWetlands"),
         Land = fct_relevel(Land, 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low", 
                            "Deciduous Forest", 
                            "Woody Wetlands"),
         patch_area_km = patch_area_mm * 1e-6) %>% 
  dplyr::rename("Impervious" = "Imperv", 
                "Dist_to_Road" = "road_dist_data", 
                "Traffic_Dist_Road" = "dist_traffic_road", 
                "Dist_to_Highway" = "highway_dist_m", 
                "Traffic_Dist_Highway" = "dist_traffic_highway")

sites <- webs %>% 
  filter(Web == "W001") 

web_dist <- webs %>% 
  filter(RetreatDist != 0,
         RetreatDist < 1000,
         Web == "W002" | Web == "W003") %>% 
  mutate(Neighbor = ifelse(Web == "W002", "1", "2"))

near <- web_dist %>% 
  filter(Neighbor == 1)
```

At one time, we tried scaling and centering the data in difference ways. I want to make mention of it here because it might be useful information for me to look back on in the future. 

- Scaling is dividing each datum by the standard deviation of the data and centering is subtracting the mean of the data from each datum to try to normalize the data.

- A second type of centering and scaling involves subtracting the median and dividing by the interquartile range.

It's important to remember to back transform when making figures. We didn't scale and center because log-transformations on right-skewed variables were enough to remove convergence errors.

```{r sites_wrangling, include = FALSE}
sites <- sites %>% 
  mutate(patch_area_km = patch_area_mm * 1e-6,
         tree100m_frac = as.numeric(tree100m/100),
         imperv100m_frac = as.numeric(imperv100m/100))
```

## Transformation of Variables

Many data are right-skewed. We check the distribution of the data and check distributions after log-transformation for right-skewed data not containing zeros. Echo = FALSE shows the results, but does not show the code used. 

```{r graphing_predictor_distributions, echo = FALSE}
# Here, we graph the distribution of predictor variables in their raw distribution and after log-transformation since all variables are positive values, and many are zero-inflated; we also run shapiro-wilk tests to test for normality including the log-transformed variable if the log-transformed distribution looks better (less skewed)

# use as is, log won't work because some data are zero
ggarrange(ggplot(sites, aes(x = tree100m)) +
  geom_density(), ggplot(sites, aes(x = tree100m_frac)) +
  geom_density(), ncol = 2, nrow = 1)
shapiro.test(sites$tree100m) # not normal
shapiro.test(sites$tree100m_frac) # not normal

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = imperv100m)) +
  geom_density()
shapiro.test(sites$imperv100m) # not normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = TotalSub)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(TotalSub))) +
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$TotalSub) # not normal
shapiro.test(log(sites$TotalSub)) # normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = Traffic_Dist_Road)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(Traffic_Dist_Road))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$Traffic_Dist_Road) # not normal
shapiro.test(log(sites$Traffic_Dist_Road)) # normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = Traffic_Dist_Highway)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(Traffic_Dist_Highway))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$Traffic_Dist_Highway) # not normal
shapiro.test(log(sites$Traffic_Dist_Highway)) # almost normal

# looks similar either way
ggarrange(ggplot(sites, aes(x = spec_rad)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(spec_rad))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$spec_rad) # not normal
shapiro.test(log(sites$spec_rad)) # not normal

# looks similar either way, but shapiro tests suggests as is is slightly better
ggarrange(ggplot(sites, aes(x = light_rad)) + 
            geom_density(), 
          ggplot(sites, aes(x = log(light_rad))) + 
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$light_rad) # not normal
shapiro.test(log(sites$light_rad)) # not normal

# better log-transformed
ggarrange(ggplot(sites, aes(x = patch_area_mm)) +
            geom_density(), 
          ggplot(sites, aes(x = log(patch_area_mm))) +
            geom_density(), 
          nrow = 1, 
          ncol = 2)
shapiro.test(sites$patch_area_mm) # not normal
shapiro.test(log(sites$patch_area_mm)) # almost normal

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = road_length_m)) + 
  geom_density()
shapiro.test(sites$road_length_m) # not normal

# use as is, log won't work because some data are zero
ggplot(sites, aes(x = trail_length_m)) + 
  geom_density()
shapiro.test(sites$trail_length_m) # not normal

sites <- sites %>% 
  mutate(log_TotalSub = log(TotalSub),
         log_tdr = log(Traffic_Dist_Road),
         log_tdh = log(Traffic_Dist_Highway),
         log_patch = log(patch_area_km))

webs <- webs %>% 
  mutate(log_TotalSub = log(TotalSub),
         log_tdr = log(Traffic_Dist_Road),
         log_tdh = log(Traffic_Dist_Highway),
         log_patch = log(patch_area_mm))

sites <- webs %>% 
  filter(Web == "W001") 

web_dist <- webs %>% 
  filter(RetreatDist != 0,
         RetreatDist < 1000,
         Web == "W002" | Web == "W003") %>% 
  mutate(Neighbor = ifelse(Web == "W002", "1", "2"))

near <- web_dist %>% 
  filter(Neighbor == 1)

webs$RetreatHeight[webs$RetreatHeight == 0] <- 0.1
```

We conclude to use log-transformations for TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, and patch_area_km.

Our analyses include looking at variation within each location. As such, this chunk subsets the "sites" and "webs" data by Location.

```{r location_subsets, include  = FALSE}
webs_center <- webs %>% 
  filter(Location == "Urban Center")

webs_forest <- webs %>% 
  filter(Location == "Urban Forest")

sites_center <- sites %>% 
  filter(Location == "Urban Center")

sites_forest <- sites %>% 
  filter(Location == "Urban Forest")

web_dist_center <- web_dist %>% 
  filter(Location == "Urban Center")

web_dist_forest <- web_dist %>% 
  filter(Location == "Urban Forest")

near_forest <- near %>% 
  filter(Location == "Urban Forest")

near_center <- near %>% 
  filter(Location == "Urban Center")
```

## Variable Reduction Based on Correlations

Since many of these variables are likely highly correlated, we want to reduce the variables that we include in our model by removing variables that are highly correlated.

```{r correlations_overall}
corr <- sites %>% 
  dplyr::select(tree100m, imperv100m, TotalSub, 
         Traffic_Dist_Road, Traffic_Dist_Highway, 
         spec_rad, light_rad, patch_area_mm, road_length_m)
# We exclude trail length from global correlations because trail length can only collected in Wilderness Park, and not for UNL City Campus

# When running findCorrelations, we get a vector of variables to remove to reduce pairwise correlations. 

findCorrelation(cor(corr, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 

# This suggests that we remove tree100m, imperv100, spec_rad, light_rad, patch_area_km, road_length_m
# That leaves us with TotalSub, Traffic_Dist_Road, and Traffic_Dist_Highway

chart.Correlation(corr, histogram = TRUE, method = "spearman") # kendall, spearman

corr <- sites %>% 
  dplyr::select(TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway)
chart.Correlation(corr, histogram = TRUE, method = "spearman") # kendall, spearman

# Let's also test the variables after transformation

corr_transformed <- sites %>% 
  dplyr::select(tree100m, imperv100m, log_TotalSub, 
         log_tdr, log_tdh, 
         spec_rad, light_rad, log_patch, road_length_m)

findCorrelation(cor(corr_transformed, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 

# This suggests to remove tree100m, imperv100m, spec_rad, light_rad, log_patch, and road_length_m.

# This leaves us with log_TotalSub, log_tdr, and log_tdh, the same results as the non-transformed. 

chart.Correlation(corr_transformed, histogram = TRUE, method = "spearman") # kendall, spearman

corr_transformed <- sites %>% 
  dplyr::select(log_TotalSub, log_tdr, log_tdh)
chart.Correlation(corr_transformed, histogram = TRUE, method = "spearman") # kendall, spearman
```

```{r correlations_forest}
corr_forest <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  dplyr::select(tree100m, imperv100m, TotalSub, 
         Traffic_Dist_Road, Traffic_Dist_Highway, 
         spec_rad, light_rad, patch_area_km, road_length_m, trail_length_m)
# Notice trail length is included 

findCorrelation(cor(corr_forest, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
# This suggests removing imperv100m, spec_rad, light_rad, road_length_m, and trail_length_m
# We will keep tree100m, TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, and patch_area_km
chart.Correlation(corr_forest, histogram = TRUE, method = "spearman")
corr_forest <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  dplyr::select(tree100m, TotalSub, Traffic_Dist_Road, patch_area_km, Traffic_Dist_Highway)
chart.Correlation(corr_forest, histogram = TRUE, method = "spearman")

# Let's try with the log-transformed
corr_forest_transformed <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  dplyr::select(tree100m, imperv100m, log_TotalSub, 
         log_tdr, log_tdh, 
         spec_rad, light_rad, log_patch, road_length_m, trail_length_m)

findCorrelation(cor(corr_forest_transformed, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
# The same variables are dropped and kept

corr_forest_transformed <- sites %>% 
  filter(Location == "Urban Forest") %>% 
  dplyr::select(tree100m, log_TotalSub, log_tdr, patch_area_km, log_tdh)
chart.Correlation(corr_forest_transformed, histogram = TRUE, method = "spearman")
```

```{r correlations_center}
corr_center <- sites %>% 
  filter(Location == "Urban Center") %>% 
  dplyr::select(tree100m, imperv100m, TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, spec_rad, light_rad, patch_area_km, road_length_m)
# Trail length is removed because we could not measure trail length on campus

findCorrelation(cor(corr_center, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
# This suggests that we remove tree100m, imperv100m, and light_rad
# We will keep TotalSub, Traffic_Dist_Road, Traffic_Dist_Highway, spec_rad, patch_area_km, and road_length_m

chart.Correlation(corr_center, histogram = TRUE, method = "spearman")

# Let's try with the transformed
corr_center_transformed <- sites %>% 
  filter(Location == "Urban Center") %>% 
  dplyr::select(tree100m, imperv100m, log_TotalSub, log_tdr, log_tdh, spec_rad, light_rad, log_patch, road_length_m)
findCorrelation(cor(corr_center_transformed, method = "spearman"), cutoff = .6, verbose = TRUE, names = TRUE) 
chart.Correlation(corr_center_transformed, histogram = TRUE, method = "pearson")
# The same variables are kept or removed
```

For overall analysis of predictors, we will include: 

- log_TotalSub

- log_tdr

- log_tdh

For the urban forest subset, we will use: 

- tree100m 

- log_TotalSub 

- log_tdr 

- log_tdh

- log_patch

Finally, for the urban center subset, we will use: 

- log_TotalSub 

- log_tdr 

- log_tdh 

- spec_rad

- log_patch

- road_length_m

## Graphs, Stats, and Assumptions Comparing Predictors by Location

Here, we just want to see if each predictor differs between the two Locations: urban forest and urban center. We build models, check assumptions of the model, and make graphs to represent differences. 

```{r stats_graphs_tree, echo = FALSE}
tree100m <- glm(tree100m ~ Location, family = "poisson", data = sites)
summary(tree100m)

# The following line tells you the mean and standard error of the raw data for tree cover in a 100 m radius of the sites between the two locations
sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(tree100m),
            se = plotrix::std.error(tree100m))

predictions <- summary(emmeans(tree100m, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = tree100m)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 100), breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)) +
  theme_classic() +
  ylab("Percent Tree Cover \n[100m radius]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=100, label="***", color="black", size = 10)
```

```{r tree_assumptions, echo = FALSE}
test_tree <- augment(tree100m, data = sites)
resid_tree <- ggplot(test_tree, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_tree$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_tree <- ggplot(test_tree, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_tree, qq_tree, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Tree cover is **significantly higher in the urban forest** than the urban center (z = -14.50, df = 1, 20, p < 0.001). The means and SE's are 47.15 ± 2.17 % for the urban forest and 1.58 ± 0.36 % for the urban center. 

```{r stats_graphs_imperv, echo = FALSE}
imperv100m <- glm(imperv100m ~ Location, family = "poisson", data = sites)
summary(imperv100m)

# The following line tells you the mean and standard error of the raw data for impervious cover in a 100 m radius of the sites between the two locations
sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(imperv100m),
            se = plotrix::std.error(imperv100m))

predictions <- summary(emmeans(imperv100m, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = imperv100m)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 100), breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100)) +
  theme_classic() +
  ylab("Percent Impervious Cover \n[100m radius]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=100, label="***", color="black", size = 10)
```

```{r imperv_assumptions, echo = FALSE}
test_imperv <- augment(imperv100m, data = sites)
resid_imperv <- ggplot(test_imperv, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_imperv$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_imperv <- ggplot(test_imperv, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_imperv, qq_imperv, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Impervious cover is **significantly higher in the urban center** than the urban forest (z = 14.51, df = 1, 20, p < 0.001). The means and SE's are 1.27 ± 0.36 % for the urban forest and 76.52 ± 2.53 % for the urban center. 

```{r stats_graphs_tdr, echo = FALSE}
tdr <- glm(log_tdr ~ Location, family = "poisson", data = sites)
summary(tdr)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_tdr),
            se = plotrix::std.error(log_tdr))

predictions <- summary(emmeans(tdr, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = exp(log_tdr))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 1400), breaks = c(0, 200, 400, 600, 800, 1000, 1200, 1400)) +
  theme_classic() +
  ylab("Road Disturbance \n[vehicles/day/m]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=1400, label="N. S.", color="black", size = 10)
```

```{r tdr_assumptions, echo = FALSE}
test_tdr <- augment(tdr, data = sites)
resid_tdr <- ggplot(test_tdr, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_tdr$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_tdr <- ggplot(test_tdr, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_tdr, qq_tdr, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

There is **no difference** in road disturbance between the urban forest and urban center (z = 1.403, df = 1, 20, p = 0.161). The means and SE's are `r exp(3.97)` ± `r exp(0.630)` vehicles/day/m for the urban forest and `r exp(5.27)` ± `r exp(0.663)` vehicles/day/m for the urban center. 

```{r stats_graphs_tdh, echo = FALSE}
tdh <- glm(log_tdh ~ Location, family = "poisson", data = sites)
summary(tdh)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_tdh),
            se = plotrix::std.error(log_tdh))

predictions <- summary(emmeans(tdh, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = exp(log_tdh))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 250), breaks = c(0, 50, 100, 150, 200, 250)) +
  theme_classic() +
  ylab("Highway Disturbance \n[vehicles/day/m]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=250, label="N. S.", color="black", size = 10)
```

```{r tdh_assumptions, echo = FALSE}
test_tdh <- augment(tdh, data = sites)
resid_tdh <- ggplot(test_tdh, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_tdh$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_tdh <- ggplot(test_tdh, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_tdh, qq_tdh, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

There is **no difference** in highway disturbance between the urban forest and urban center (z = 0.530, df = 1, 20, p = 0.596). The means and SE's are `r exp(3.52)` ± `r exp(0.593)` vehicles/day/m for the urban forest and `r exp(3.96)` ± `r exp(0.574)` vehicles/day/m for the urban center. 

```{r stats_graphs_plant, echo = FALSE}
plant <- glm(log_TotalSub ~ Location, family = "poisson", data = sites)
summary(plant)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_TotalSub),
            se = plotrix::std.error(log_TotalSub))

predictions <- summary(emmeans(plant, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = exp(log_TotalSub))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 25), breaks = c(0, 5, 10, 15, 20, 25)) +
  theme_classic() +
  ylab("Plant Species Richness \n[species/site]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=25, label="*", color="black", size = 10)
```

```{r plant_assumptions, echo = FALSE}
test_plant <- augment(plant, data = sites)
resid_plant <- ggplot(test_plant, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_plant$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_plant <- ggplot(test_plant, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_plant, qq_plant, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Plant species richness is **significantly higher in the urban forest** than the urban center (z = -2.430, df = 1, 20, p = 0.015). The means and SE's are `r exp(2.50)` ± `r exp(0.500)` species for the urban forest and `r exp(1.09)` ± `r exp(0.302)` species for the urban center. 

```{r stats_graphs_spec, echo = FALSE}
spec <- glm(spec_rad ~ Location, family = "poisson", data = sites)
summary(spec)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(spec_rad),
            se = plotrix::std.error(spec_rad))

predictions <- summary(emmeans(spec, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = spec_rad)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(130, 165), breaks = c(130, 135, 140, 145, 150, 155, 160, 165)) +
  theme_classic() +
  ylab("Spectral Radiance \n[Watts/(m² * sr * µm)]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=165, label="**", color="black", size = 10)
```

```{r spec_assumptions, echo = FALSE}
test_spec <- augment(plant, data = sites)
resid_spec <- ggplot(test_spec, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_spec$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_spec <- ggplot(test_spec, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_spec, qq_spec, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Spectral radiance is **significantly higher in the urban center** than the urban forest (z = 3.079, df = 1, 20, p = 0.002). The means and SE's are 137.44 ± 3.71 Watts/(m² * sr * µm) for the urban forest and 153.39 ± 3.58 Watts/(m² * sr * µm) for the urban center. 

```{r stats_graphs_light, echo = FALSE}
light <- glm(light_rad ~ Location, family = "poisson", data = sites)
summary(light)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(light_rad),
            se = plotrix::std.error(light_rad))

predictions <- summary(emmeans(light, ~Location),type = "response")
predictions 

ggplot(sites, aes(x = Location, y = light_rad)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 175), breaks = c(0, 25, 50, 75, 100, 125, 150, 175)) +
  theme_classic() +
  ylab("Radiance [mcd/m²]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=175, label="***", color="black", size = 10)
```

```{r light_assumptions, echo = FALSE}
test_light <- augment(plant, data = sites)
resid_light <- ggplot(test_light, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_light$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_light <- ggplot(test_light, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_light, qq_light, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Light radiance is **significantly higher in the urban center** than the urban forest (z = 22.46, df = 1, 20, p < 0.001). The means and SE's are 5.89 ± 0.77 mcd/m² for the urban forest and 116.90 ± 3.12 mcd/m² for the urban center.

```{r stats_graphs_patch, echo = FALSE}
patch <- glm(log_patch ~ Location, family = "poisson", data = sites)
summary(patch)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(log_patch),
            se = plotrix::std.error(log_patch))

predictions <- summary(emmeans(patch, ~Location),type = "response")
predictions 

ggplot(sites, aes(x = Location, y = exp(log_patch))) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = exp(rate), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(rate - SE), 
                  ymax = exp(rate + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 130310), breaks = c(0, 20000, 40000, 60000, 80000, 100000, 120000)) +
  theme_classic() +
  ylab("Patch Area [mm²]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=130310, label="***", color="black", size = 10)
```

```{r patch_assumptions, echo = FALSE}
test_patch <- augment(patch, data = sites)
resid_patch <- ggplot(test_patch, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_patch$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_patch <- ggplot(test_patch, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_patch, qq_patch, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Patch area is **significantly higher in the urban forest** than the urban center (z = -3.599, df = 1, 20, p < 0.001). The means and SE's are `r exp(10.52)` ± `r exp(1.026)` mm² for the urban forest and `r exp(6.08)` ± `r exp(0.712)` mm² for the urban center. 

```{r stats_graphs_road, echo = FALSE}
road <- glm(road_length_m ~ Location, family = "poisson", data = sites)
summary(road)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(road_length_m),
            se = plotrix::std.error(road_length_m))

predictions <- summary(emmeans(road, ~Location),type = "response")
predictions

ggplot(sites, aes(x = Location, y = road_length_m)) + 
  geom_jitter(color = "grey", width = 0.1, size = 1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, linewidth = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  scale_y_continuous(limits=c(0, 140), breaks = c(0, 20, 40, 60, 80, 100, 120, 140)) +
  theme_classic() +
  ylab("Total Length of Road \n[m, 100m radius]") + 
  theme(text = element_text(size = 18)) + 
  theme(axis.text.x=element_text(colour="black", size=18)) + 
  theme(axis.text.y=element_text(colour="black", size=18),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom="text", x=1.5, y=140, label="***", color="black", size = 10)
```

```{r road_assumptions, echo = FALSE}
test_road <- augment(road, data = sites)
resid_road <- ggplot(test_road, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_road$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_road <- ggplot(test_road, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

ggarrange(resid_road, qq_road, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```

Total road length is **significantly higher in the urban center** than the urban forest (z = 20.89, df = 1, 20, p < 0.001). The means and SE's are 15.67 ± 1.25 m for the urban forest and 93.03 ± 2.78 m for the urban center. 

## Response Variable: Search Distance

### Search Distance by Location

For this variable, I've gone back and forth on whether I should log-transform the search distance (because it can be ran Gaussian), or whether to use a log-link function (Poisson Distribution). The poisson glm more closely matches the mean, but the log-transformation is better at capturing the variance. Each step of the way, I have performed each test to try and gauge a best route forward. The poisson glm suggests a significant difference while the log-transformed shows no difference. 

```{r search_location_stats}
ggarrange(ggplot(sites, aes(x = WalkDist)) +
            geom_density(),
          ggplot(sites, aes(x = log(WalkDist))) +
            geom_density(), ncol = 2)

shapiro.test(sites$WalkDist) # not normal
shapiro.test(log(sites$WalkDist)) # normal

search <- glm(WalkDist ~ Location, data = sites, family = poisson)
summary(search)

search2 <- glm(log(WalkDist) ~ Location, data = sites)
summary(search2)

sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(WalkDist),
            se = plotrix::std.error(WalkDist))
```

```{r search_location_assumptions, echo = FALSE}
# As is, Poisson
test_search <- augment(search, data = sites)
resid_search <- ggplot(test_search, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_search$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_search <- ggplot(test_search, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_search <- ggplot(test_search, aes(x = .fitted, y = sqrt(abs(.std.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_search <- ggplot(test_search, aes(.hat, .std.resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_search, qq_search, scaleloc_search, lev_search, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)

# Log-transformed, Normal
test_search2 <- augment(search2, data = sites)
resid_search2 <- ggplot(test_search2, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_search2$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_search2 <- ggplot(test_search2, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

scaleloc_search2 <- ggplot(test_search2, aes(x = .fitted, y = sqrt(abs(.std.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_search2 <- ggplot(test_search2, aes(.hat, .std.resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_search2, qq_search2, scaleloc_search2, lev_search2, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)
```

```{r search_location_graph, echo = FALSE}
# raw data
raw <- sites %>% 
  group_by(Location) %>% 
  summarise(mean = mean(WalkDist),
            se = plotrix::std.error(WalkDist))


raw_plot_search <- ggplot(sites, aes(x = Location, y = WalkDist)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = mean, color = Location), size = 2, data = raw) +
  geom_errorbar(aes(x= Location, 
                    ymin = mean - se, 
                    ymax = mean + se, 
                    color = Location), data = raw, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 275), breaks = c(0, 50, 100, 150, 200, 250)) +
    xlab("Collection Location") +
    ylab("Search Distance [m]") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
    theme(legend.position = "none")

# Non-transformed, poisson distribution
nd <- data.frame(Location = factor(levels(sites$Location)))
predictions <- augment(search, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("rate" = ".fitted", "SE" = ".se.fit")
#predictions2 <- summary(emmeans(search, ~Location),type = "response")

poisson_plot_search <- ggplot(sites, aes(x = Location, y = WalkDist)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
  scale_y_continuous(limits = c(0, 275), breaks = c(0, 50, 100, 150, 200, 250)) +
  xlab("Collection Location") +
  ylab("Search Distance [m]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 275, label = "***", color = "black", size = 5)

# Let's look at the log-transformed response variable since that is normal
nd <- data.frame(Location = factor(levels(sites$Location)))
predictions2 <- augment(search2, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions2 <- predictions2 %>% 
  rename("response" = ".fitted", "SE" = ".se.fit")
#predictions2 <- summary(emmeans(search2, ~Location),type = "response")

log_plot_search <- ggplot(sites, aes(x = Location, y = (WalkDist))) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = exp(response), color = Location), size = 2, data = predictions2) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(response - SE), 
                  ymax = exp(response + SE),
                  color = Location), data = predictions2, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
  scale_y_continuous(limits = c(0, 275), breaks = c(0, 50, 100, 150, 200, 250)) +
  xlab("Collection Location") +
  ylab("Search Distance [m]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 275, label = "", color = "black", size = 5)

ggarrange(raw_plot_search, 
          poisson_plot_search, 
          log_plot_search, 
          labels = c("Raw Data", "Poisson Distribution", "Log-Transformed"),
          nrow = 1)
```

Using a Poisson distribution, we **searched significantly further at sites in the urban forest** than the urban center to reach the focal web (z = -10.1, df = 1, 20, p < 0.001).

### Search Distance by Predictors

```{r search_predictors_stats}
# This is one way to look at the overall data, but I think I end up not using this information
models = list(WalkDist ~ 1,
              WalkDist ~ log_TotalSub, 
              WalkDist ~ log_tdr, 
              WalkDist ~ log_tdh,
              WalkDist ~ log_TotalSub + log_tdr,
              WalkDist ~ log_TotalSub + log_tdh,
              WalkDist ~ log_tdr + log_tdh,
              WalkDist ~ log_TotalSub + log_tdr + log_tdh)
fits = lapply(models, glm, data = sites, family = "poisson")
modnames = sapply(models, function(ff)deparse(ff[[3]]))
pander(aictab(fits, modname = modnames), caption="Table 1. AICc model selection table for Search Distance to the Focal Web Overall.", split.tables = Inf)
# The top model keeps all 3 variables and no other model is within 2 Model Likelihood Units
summary(glm(WalkDist ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson))


global <- glm(WalkDist ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_sd_o <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_sd_o)
out
info <- out[[12]]
#TotalSub (log_TotalSub)
exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Road (log_tdr)
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Highway (log_tdh)
exp(info[2, 1])
exp(info[2, 2])

with(summary(top_model_sd_o), 1 - deviance/null.deviance) # This gives the R squared value
#summary(model.avg(model_dredge, subset = delta <= 2))
#summary(model.avg(model_dredge))
model.sel(model_dredge) #estimates same signs
car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban forest
global <- glm(WalkDist ~ tree100m + log_TotalSub + log_tdh + log_patch + log_tdr, data = sites_forest, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_sd_f <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_sd_f)
out
info <- out[[12]]
#tree100m
info[5, 1]
info[5, 2]
#TotalSub
-exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Road
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Highway
exp(info[2, 1])
exp(info[2, 2])
with(summary(top_model_sd_f), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban center
global <- glm(WalkDist ~ log_TotalSub + log_tdr + log_tdh + spec_rad + log_patch + road_length_m, data = sites_center, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_sd_c <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_sd_c)
out
info <- out[[12]]
#TotalSub
exp(info[5, 1])
exp(info[5, 2])
#patch_area_km
exp(info[2, 1])
exp(info[2, 2])
#spec_rad
info[6, 1]
info[6, 2]
#Traffic_Dist_Road
exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Highway
exp(info[3, 1])
exp(info[3, 2])
with(summary(top_model_sd_c), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 1)[[1]]) # road and highway disturbance between 2 and 3
```

*Overall*
Coefficients:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)   2.45699    0.24451  10.049  < 2e-16 ***
log_tdh       0.21434    0.04469   4.796 1.62e-06 *** **positive**
log_tdr       0.13279    0.01775   7.480 7.42e-14 *** **positive**
log_TotalSub  0.31671    0.03252   9.740  < 2e-16 *** **positive**

R-squared = 0.0821148

*Urban Forest*
Coefficients:
              Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -2.962190   0.608574  -4.867 1.13e-06 ***
log_tdh       1.354582   0.109952  12.320  < 2e-16 *** **positive**
log_tdr       0.718623   0.038386  18.721  < 2e-16 *** **positive**
log_TotalSub -1.010040   0.095179 -10.612  < 2e-16 *** **negative**
tree100m      0.049914   0.004241  11.770  < 2e-16 *** **positive**

R-squared = 0.5328974

*Urban Center*
Coefficients:
              Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -26.90656    2.78649  -9.656  < 2e-16 ***
log_patch      1.05254    0.05903  17.832  < 2e-16 *** **positive** 
log_tdh        0.58001    0.09128   6.354 2.10e-10 *** **positive**
log_tdr        0.45331    0.04386  10.335  < 2e-16 *** **positive**
log_TotalSub   0.54581    0.08135   6.709 1.96e-11 *** **positive**
spec_rad       0.12466    0.01458   8.549  < 2e-16 *** **positive**

R-squared = 0.9399876

```{r search_predictors_overall_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 3.2, 0.03), 
                 log_tdr = mean(sites$log_tdr), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_sd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
search_plant <- ggplot(sites, aes(x = log_TotalSub, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$WalkDist)), max(log(sites$WalkDist)) + 0.1 * diff(range(log(sites$WalkDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(sites$WalkDist)), label = "***", color = "black", size = 4)

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdr = seq(2.7, 7.3, 0.05), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_sd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
search_tdr <- ggplot(sites, aes(x = log_tdr, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$WalkDist)), max(log(sites$WalkDist)) + 0.1 * diff(range(log(sites$WalkDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites$WalkDist)), label = "***", color = "black", size = 4)

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdr = mean(sites$log_tdr), 
                 log_tdh = seq(2.7, 5.5, 0.03))
predicted.distance <- augment(top_model_sd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
search_tdh <- ggplot(sites, aes(x = log_tdh, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$WalkDist)), max(log(sites$WalkDist)) + 0.1 * diff(range(log(sites$WalkDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites$WalkDist)), label = "***", color = "black", size = 4)

search_plant
search_tdr
search_tdh
```

```{r search_predictors_forest_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Tree
nd <- data.frame(tree100m = seq(31, 66, 0.3),
                 log_TotalSub = mean(sites_forest$log_TotalSub), 
                 log_tdr = mean(sites_forest$log_tdr), 
                 log_tdh = mean(sites_forest$log_tdh))
predicted.distance <- augment(top_model_sd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_tree <- ggplot(sites_forest, aes(x = (tree100m), y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (tree100m), y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = (tree100m), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.1 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Percent Tree Cover [%]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$tree100m)) + diff(range((predicted.distance$tree100m)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)

# TotalSub
nd <- data.frame(tree100m = mean(sites_forest$tree100m),
                 log_TotalSub = seq(1.94, 3.14, 0.01), 
                 log_tdr = mean(sites_forest$log_tdr), 
                 log_tdh = mean(sites_forest$log_tdh))
predicted.distance <- augment(top_model_sd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_plant <- ggplot(sites_forest, aes(x = log_TotalSub, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.1 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_TotalSub)) + diff(range((predicted.distance$log_TotalSub)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)  

# Road Disturbance
nd <- data.frame(tree100m = mean(sites_forest$tree100m),
                 log_TotalSub = mean(sites_forest$log_TotalSub), 
                 log_tdr = seq(2.73, 6.22, 0.03), 
                 log_tdh = mean(sites_forest$log_tdh))
predicted.distance <- augment(top_model_sd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_tdr <- ggplot(sites_forest, aes(x = log_tdr, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.15 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)  

# Highway Disturbance
nd <- data.frame(tree100m = mean(sites_forest$tree100m),
                 log_TotalSub = mean(sites_forest$log_TotalSub), 
                 log_tdr = mean(sites_forest$log_tdr), 
                 log_tdh = seq(2.76, 3.89, 0.01))
predicted.distance <- augment(top_model_sd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
search_forest_tdh <- ggplot(sites_forest, aes(x = log_tdh, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_forest$WalkDist)), max(log(sites_forest$WalkDist)) + 0.1 * diff(range(log(sites_forest$WalkDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites_forest$WalkDist)), label = "***", color = "black", size = 4)

search_forest_tree
search_forest_plant
search_forest_tdr
search_forest_tdh
```

```{r search_predictors_center_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 1.8, 0.02), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_sd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_plant <- ggplot(sites_center, aes(x = log_TotalSub, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_TotalSub)) + diff(range((predicted.distance$log_TotalSub)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Patch Area
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = seq(4.34, 7.52, 0.03),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_sd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_patch <- ggplot(sites_center, aes(x = log_patch, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_patch, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_patch, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)) - 0.75, max(log(sites_center$WalkDist)) + 0.15 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Patch Area [log(mm²)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_patch)) + diff(range((predicted.distance$log_patch)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Spectral Radiance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = seq(144.36, 162.87, 0.1),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_sd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_spec <- ggplot(sites_center, aes(x = (spec_rad), y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (spec_rad), y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = (spec_rad), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Spectral Radiance [Watts/(m² * sr * µm)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$spec_rad)) + diff(range((predicted.distance$spec_rad)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = seq(3.00, 7.22, 0.04), 
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_sd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_tdr <- ggplot(sites_center, aes(x = log_tdr, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 spec_rad = mean(sites_center$spec_rad),
                 log_tdr = mean(sites_center$log_tdr), 
                 log_tdh = seq(3.32, 5.42, 0.02))
predicted.distance <- augment(top_model_sd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
search_center_tdh <- ggplot(sites_center, aes(x = log_tdh, y = log(WalkDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$WalkDist)), max(log(sites_center$WalkDist)) + 0.1 * diff(range(log(sites_center$WalkDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Search Distance [log(m)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites_center$WalkDist)), label = "***", color = "black", size = 4) 

search_center_plant
search_center_patch
search_center_spec
search_center_tdr
search_center_tdh
```

### Search Distance by Land

```{r search_land_stats}
search_land <- glm(WalkDist ~ Land, data = sites, family = poisson)
summary(search_land)
car::Anova(search_land, test.statistic = "LR")
comp <- glht(search_land, linfct = mcp(Land = "Tukey"))
summary(comp)
```

```{r search_land_graph}
sites <- sites %>% 
  mutate(Land = fct_relevel(Land, "Deciduous Forest", 
                            "Woody Wetlands", 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low"))
nd <- data.frame(Land = factor(levels(sites$Land)))
predictions <- augment(search_land, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("rate" = ".fitted", "SE" = ".se.fit")
#predictions <- summary(emmeans(search_land, ~Land),type = "response")

search_land_plot <- ggplot(sites, aes(x = Land, y = WalkDist)) + 
  geom_jitter(color = "grey", width = 0.1, size = 0.5) +
  geom_point(aes(x = Land, y = rate, color = Land), size = 1, data = predictions) + 
  geom_errorbar(aes(x = Land, 
                  ymin = rate - SE, 
                  ymax = rate + SE, color = Land), data = predictions, inherit.aes = FALSE, width = 0.25, size = 1) +
  theme_classic() +
  scale_color_manual(values = c("Deciduous Forest" = "#1b9e77", "Woody Wetlands" = "#1b9e77", "Urban, High" = "#d95f02", "Urban, Medium" = "#d95f02", "Urban, Low" = "#d95f02")) +
  xlab("Land Cover Class") +
  ylab("Search Distance [m]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) +
  annotate(geom="text", x=1, y=max(sites$WalkDist), label="A", color="black", size = 3) +
  annotate(geom="text", x=2, y=max(sites$WalkDist), label="B", color="black", size = 3) +
  annotate(geom="text", x=3, y=max(sites$WalkDist), label="C", color="black", size = 3) +
  annotate(geom="text", x=4, y=max(sites$WalkDist), label="A", color="black", size = 3) +
  annotate(geom="text", x=5, y=max(sites$WalkDist), label="A", color="black", size = 3)

search_land_plot
```

**Search distance significantly varies** by land class (Chi = 340.32, df = 4, p < 0.001).

## Response Variable: Number of Webs

### Number of Webs by Location

I also tested Poisson glm vs log-transformation here since log-transformed does help make the data more Gaussian. However, similar results arise in this case.

```{r webs_location_stats}
ggarrange(ggplot(sites, aes(x = NumWebs)) +
            geom_density(),
          ggplot(sites, aes(x = log(NumWebs))) +
            geom_density(), ncol = 2)

shapiro.test(sites$NumWebs) # not normal
shapiro.test(log(sites$NumWebs)) # just normal

web <- glm(NumWebs ~ Location, data = sites, family = poisson)
summary(web)

web2 <- glm(log(NumWebs) ~ Location, data = sites)
summary(web)

# Both methods yield similar results
sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(NumWebs),
            se = plotrix::std.error(NumWebs))
```

```{r webs_location_assumptions, echo = FALSE}
# As is, Poisson
test_webs <- augment(web, data = sites)
resid_webs <- ggplot(test_webs, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_webs$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_webs <- ggplot(test_webs, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_webs <- ggplot(test_webs, aes(x = .fitted, y = sqrt(abs(.std.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_webs <- ggplot(test_webs, aes(.hat, .std.resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_webs, qq_webs, scaleloc_webs, lev_webs, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)

# Log-transformed, Normal
test_webs2 <- augment(web2, data = sites)
resid_webs2 <- ggplot(test_webs2, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_webs2$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_webs2 <- ggplot(test_webs2, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_webs2 <- ggplot(test_webs2, aes(x = .fitted, y = sqrt(abs(.std.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_webs2 <- ggplot(test_webs2, aes(.hat, .std.resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_webs2, qq_webs2, scaleloc_webs2, lev_webs2, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)
```

```{r webs_location_graph, echo = FALSE}
# raw data
raw <- sites %>% 
  group_by(Location) %>% 
  summarise(mean = mean(NumWebs),
            se = plotrix::std.error(NumWebs))


raw_plot_webs <- ggplot(sites, aes(x = Location, y = NumWebs)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = mean, color = Location), size = 2, data = raw) +
  geom_errorbar(aes(x= Location, 
                    ymin = mean - se, 
                    ymax = mean + se, 
                    color = Location), data = raw, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 75), breaks = c(0, 15, 30, 45, 60, 75)) +
    ylab("Number of Webs") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
    theme(legend.position = "none")

# Non-transformed, poisson distribution
nd <- data.frame(Location = factor(levels(sites$Location)))
predictions <- augment(web, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("rate" = ".fitted", "SE" = ".se.fit")
#predictions <- summary(emmeans(web, ~Location),type = "response")

poisson_plot_webs <- ggplot(sites, aes(x = Location, y = NumWebs)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
    scale_y_continuous(limits = c(0, 75), breaks = c(0, 15, 30, 45, 60, 75)) +
  ylab("Number of Webs") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 75, label = "***", color = "black", size = 5) 

# Let's look at the log-transformed response variable since that is normal
nd <- data.frame(Location = factor(levels(sites$Location)))
predictions <- augment(web2, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("response" = ".fitted", "SE" = ".se.fit")
#predictions2 <- summary(emmeans(webs2, ~Location),type = "response")

log_plot_webs <- ggplot(sites, aes(x = Location, y = (NumWebs))) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = exp(response), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(response - SE), 
                  ymax = exp(response + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
    scale_y_continuous(limits = c(0, 75), breaks = c(0, 15, 30, 45, 60, 75)) +
  ylab("Number of Webs") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 75, label = "**", color = "black", size = 5)

ggarrange(raw_plot_webs, 
          poisson_plot_webs, 
          log_plot_webs, 
          labels = c("Raw Data", "Poisson Distribution", "Log-Transformed"),
          nrow = 1)
```

There were **significantly more webs at sites in the urban center** than the urban forest (z = 8.556, df = 1, 20, p < 0.001).

### Number of Webs by Predictors

```{r webs_predictors_stats}
# This is one way to look at the overall data, but I think I end up not using this information
models = list(NumWebs ~ 1,
              NumWebs ~ log_TotalSub, 
              NumWebs ~ log_tdr, 
              NumWebs ~ log_tdh,
              NumWebs ~ log_TotalSub + log_tdr,
              NumWebs ~ log_TotalSub + log_tdh,
              NumWebs ~ log_tdr + log_tdh,
              NumWebs ~ log_TotalSub + log_tdr + log_tdh)
fits = lapply(models, glm, data = sites, family = "poisson")
modnames = sapply(models, function(ff)deparse(ff[[3]]))
pander(aictab(fits, modname = modnames), caption="Table 1. AICc model selection table for Search Distance to the Focal Web Overall.", split.tables = Inf)
# The top model keeps all 3 variables and no other model is within 2 Model Likelihood Units
summary(glm(NumWebs ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson))


global <- glm(NumWebs ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_nw_o <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_nw_o)
out
info <- out[[12]]
#TotalSub (log_TotalSub)
exp(info[4, 1])
exp(info[4, 2])
#Traffic_Dist_Road (log_tdr)
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Highway (log_tdh)
exp(info[2, 1])
exp(info[2, 2])

with(summary(top_model_nw_o), 1 - deviance/null.deviance) # This gives the R squared value
#summary(model.avg(model_dredge, subset = delta <= 2))
#summary(model.avg(model_dredge))
model.sel(model_dredge) #estimates same signs
car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban forest
global <- glm(NumWebs ~ tree100m + log_TotalSub + log_tdh + log_patch + log_tdr, data = sites_forest, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_nw_f <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_nw_f)
out
info <- out[[12]]
with(summary(top_model_nw_f), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
#car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban center
global <- glm(NumWebs ~ log_TotalSub + log_tdr + log_tdh + spec_rad + log_patch + road_length_m, data = sites_center, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_nw_c <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_nw_c)
out
info <- out[[12]]
#TotalSub
exp(info[4, 1])
exp(info[4, 2])
#patch_area_km
exp(info[2, 1])
exp(info[2, 2])
#Traffic_Dist_Highway
exp(info[3, 1])
exp(info[3, 2])
#road_length
info[5, 1]
info[5, 2]
with(summary(top_model_nw_c), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
summary(model.avg(model_dredge, subset = delta <= 2))
# We'll use the conditional average
#TotalSub
-exp(0.659231)
exp(0.186648)
#patch_area_km
-exp(0.293327)
exp(0.113716)
#Traffic_Dist_Highway
-exp(1.560993)
exp(0.192352)
#road_length_m
-0.021230 
0.004766
car::vif(get.models(model_dredge, 1)[[1]]) # looking for values < 2
```

*Overall*
Coefficients:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)   7.55449    0.87254   8.658  < 2e-16 ***
log_tdh      -1.26833    0.19726  -6.430 1.28e-10 *** **negative**
log_tdr       0.18726    0.04729   3.960 7.49e-05 *** **positive**
log_TotalSub -1.02619    0.09768 -10.505  < 2e-16 *** **negative**

R-squared = 0.556197

*Urban Forest*
Coefficients:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept)   1.0986     0.1826   6.017 1.77e-09 ***

R-squared = -6.661338e-16

*Urban Center*
Coefficients:
               Estimate Std. Error z value Pr(>|z|)    
(Intercept)   13.145965   1.236110  10.635  < 2e-16 ***
log_patch     -0.293327   0.113716  -2.579   0.0099 **  **negative**
log_tdh       -1.539660   0.190172  -8.096 5.67e-16 *** **negative**
log_TotalSub  -0.717109   0.183835  -3.901 9.59e-05 *** **negative**
road_length_m -0.022553   0.004713  -4.785 1.71e-06 *** **negative**

R-squared = 0.5814882

(conditional average) 
               Estimate Std. Error Adjusted SE z value Pr(>|z|)    
(Intercept)   12.284984   1.481836    1.650697   7.442  < 2e-16 ***
log_patch     -0.293327   0.113716    0.137194   2.138 0.032513 *   **negative**
log_tdh       -1.560993   0.192352    0.229029   6.816  < 2e-16 *** **negative**
log_TotalSub  -0.659231   0.186648    0.218846   3.012 0.002593 **  **negative**
road_length_m -0.021230   0.004766    0.005608   3.786 0.000153 *** **negative**

```{r webs_predictors_overall_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 3.2, 0.03), 
                 log_tdr = mean(sites$log_tdr), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_nw_o, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_plant <- ggplot(sites, aes(x = log_TotalSub, y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$NumWebs)), max(log(sites$NumWebs)) + 0.1 * diff(range(log(sites$NumWebs))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(sites$NumWebs)), label = "***", color = "black", size = 4)

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdr = seq(2.7, 7.3, 0.05), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_nw_o, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_tdr <- ggplot(sites, aes(x = log_tdr, y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$NumWebs)), max(log(sites$NumWebs)) + 0.1 * diff(range(log(sites$NumWebs))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(sites$NumWebs)), label = "***", color = "black", size = 4)

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdr = mean(sites$log_tdr), 
                 log_tdh = seq(2.7, 5.5, 0.03))
predicted.distance <- augment(top_model_nw_o, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_tdh <- ggplot(sites, aes(x = log_tdh, y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$NumWebs)) - 1.2, max(log(sites$NumWebs)) + 0.1 * diff(range(log(sites$NumWebs))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites$NumWebs)), label = "***", color = "black", size = 4)

webs_plant
webs_tdr
webs_tdh
```

```{r webs_predictors_center_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 1.8, 0.02), 
                 log_patch = mean(sites_center$log_patch),
                 road_length_m = mean(sites_center$road_length_m),
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_nw_c, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_center_plant <- ggplot(sites_center, aes(x = log_TotalSub, y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumWebs)), max(log(sites_center$NumWebs)) + 0.1 * diff(range(log(sites_center$NumWebs))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_TotalSub)) + diff(range((predicted.distance$log_TotalSub)))/2, y = max(log(sites_center$NumWebs)), label = "***", color = "black", size = 4) 

# Patch Area
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = seq(4.34, 7.52, 0.025),
                 road_length_m = mean(sites_center$road_length_m),
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_nw_c, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_center_patch <- ggplot(sites_center, aes(x = log_patch, y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_patch, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_patch, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumWebs)) - 0.75, max(log(sites_center$NumWebs)) + 0.15 * diff(range(log(sites_center$NumWebs))))) +  
  theme_classic() +
  xlab("Patch Area [log(mm²)]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_patch)) + diff(range((predicted.distance$log_patch)))/2, y = max(log(sites_center$NumWebs)), label = "**", color = "black", size = 4) 

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 road_length_m = mean(sites_center$road_length_m),
                 log_tdh = seq(3.32, 5.42, 0.02))
predicted.distance <- augment(top_model_nw_c, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_center_tdh <- ggplot(sites_center, aes(x = log_tdh, y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumWebs)) - 0.75, max(log(sites_center$NumWebs)) + 0.1 * diff(range(log(sites_center$NumWebs))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites_center$NumWebs)), label = "***", color = "black", size = 4) 

# Road Length
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 road_length_m = seq(47, 136, 1),
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_nw_c, 
                              newdata = nd, 
                              se_fit = TRUE)
webs_center_road <- ggplot(sites_center, aes(x = (road_length_m), y = log(NumWebs))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (road_length_m), y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = (road_length_m), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumWebs)), max(log(sites_center$NumWebs)) + 0.1 * diff(range(log(sites_center$NumWebs))))) +  
  theme_classic() +
  xlab("Total Road Length [m]") +
  ylab("Number of Webs [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$road_length_m)) + diff(range((predicted.distance$road_length_m)))/2, y = max(log(sites_center$NumWebs)), label = "***", color = "black", size = 4) 

webs_center_plant
webs_center_patch
webs_center_road
webs_center_tdh
```

### Number of Webs by Land

```{r webs_land_stats}
webs_land <- glm(NumWebs ~ Land, data = sites, family = poisson)
summary(webs_land)
car::Anova(webs_land, test.statistic = "LR")
comp <- glht(webs_land, linfct = mcp(Land = "Tukey"))
summary(comp)
```

```{r webs_land_graph}
sites <- sites %>% 
  mutate(Land = fct_relevel(Land, "Deciduous Forest", 
                            "Woody Wetlands", 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low"))
nd <- data.frame(Land = factor(levels(sites$Land)))
predictions <- augment(webs_land, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("rate" = ".fitted", "SE" = ".se.fit")
#predictions <- summary(emmeans(webs_land, ~Land),type = "response")

webs_land_plot <- ggplot(sites, aes(x = Land, y = NumWebs)) + 
  geom_jitter(color = "grey", width = 0.1, size = 0.5) +
  geom_point(aes(x = Land, y = rate, color = Land), size = 1, data = predictions) + 
  geom_errorbar(aes(x = Land, 
                  ymin = rate - SE, 
                  ymax = rate + SE, color = Land), data = predictions, inherit.aes = FALSE, width = 0.25, size = 1) +
  theme_classic() +
  scale_color_manual(values = c("Deciduous Forest" = "#1b9e77", "Woody Wetlands" = "#1b9e77", "Urban, High" = "#d95f02", "Urban, Medium" = "#d95f02", "Urban, Low" = "#d95f02")) +
  xlab("Land Cover Class") +
  ylab("Number of Webs") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) +
  annotate(geom="text", x=1, y=max(sites$NumWebs), label="A", color="black", size = 3) +
  annotate(geom="text", x=2, y=max(sites$NumWebs), label="A", color="black", size = 3) +
  annotate(geom="text", x=3, y=max(sites$NumWebs), label="B", color="black", size = 3) +
  annotate(geom="text", x=4, y=max(sites$NumWebs), label="B", color="black", size = 3) +
  annotate(geom="text", x=5, y=max(sites$NumWebs), label="B", color="black", size = 3)

webs_land_plot_nox <- webs_land_plot + 
  theme(axis.text.x = element_blank()) + 
  theme(axis.title.x = element_blank())

webs_land_plot
```

The **number of webs significantly varies** by land cover class (chi = 106.67, df = 4, p < 0.001).

## Response Variable: Number of Spiders

### Number of Spiders by Location

```{r spiders_location_stats}
ggarrange(ggplot(sites, aes(x = NumSpiders)) +
            geom_density(),
          ggplot(sites, aes(x = log(NumSpiders))) +
            geom_density(), ncol = 2)

shapiro.test(sites$NumSpiders) # not normal
shapiro.test(log(sites$NumSpiders)) # not normal

spiders <- glm(NumSpiders ~ Location, data = sites, family = poisson)
summary(spiders)

spiders2 <- glm(log(NumSpiders) ~ Location, data = sites)
summary(spiders2)

# Both methods yield similar results
sites %>% 
  group_by(Location) %>% 
  summarize(mean = mean(NumSpiders),
            se = plotrix::std.error(NumSpiders))
```

```{r spiders_location_assumptions, echo = FALSE}
# As is, Poisson
test_spiders <- augment(spiders, data = sites)
resid_spiders <- ggplot(test_spiders, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_spiders$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_spiders <- ggplot(test_spiders, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_spiders <- ggplot(test_spiders, aes(x = .fitted, y = sqrt(abs(.std.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_spiders <- ggplot(test_spiders, aes(.hat, .std.resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_spiders, qq_spiders, scaleloc_spiders, lev_spiders, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)

# Log-transformed, Normal
test_spiders2 <- augment(spiders2, data = sites)
resid_spiders2 <- ggplot(test_spiders2, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_spiders2$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_spiders2 <- ggplot(test_spiders2, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_spiders2 <- ggplot(test_spiders2, aes(x = .fitted, y = sqrt(abs(.std.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_spiders2 <- ggplot(test_spiders2, aes(.hat, .std.resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_spiders2, qq_spiders2, scaleloc_spiders2, lev_spiders2, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)
```

```{r spiders_location_graph, echo = FALSE}
# raw data
raw <- sites %>% 
  group_by(Location) %>% 
  summarise(mean = mean(NumSpiders),
            se = plotrix::std.error(NumSpiders))


raw_plot_spiders <- ggplot(sites, aes(x = Location, y = NumSpiders)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = mean, color = Location), size = 2, data = raw) +
  geom_errorbar(aes(x= Location, 
                    ymin = mean - se, 
                    ymax = mean + se, 
                    color = Location), data = raw, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 25), breaks = c(0, 5, 10, 15, 20, 25)) +
    ylab("Number of Spiders") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
    theme(legend.position = "none") 

# Non-transformed, poisson distribution
nd <- data.frame(Location = factor(levels(sites$Location)))
predictions <- augment(spiders, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("rate" = ".fitted", "SE" = ".se.fit")
#predictions <- summary(emmeans(spiders, ~Location),type = "response")

poisson_plot_spiders <- ggplot(sites, aes(x = Location, y = NumSpiders)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = rate, color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = rate - SE, 
                  ymax = rate + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
    scale_y_continuous(limits = c(0, 25), breaks = c(0, 5, 10, 15, 20, 25)) +
  ylab("Number of Spiders") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 25, label = "***", color = "black", size = 5)

# Let's look at the log-transformed response variable since that is normal
nd <- data.frame(Location = factor(levels(sites$Location)))
predictions <- augment(spiders2, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("response" = ".fitted", "SE" = ".se.fit")
#predictions2 <- summary(emmeans(webs2, ~Location),type = "response")

log_plot_spiders <- ggplot(sites, aes(x = Location, y = (NumSpiders))) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = exp(response), color = Location), size = 2, data = predictions) + 
  geom_errorbar(aes(x = Location, 
                  ymin = exp(response - SE), 
                  ymax = exp(response + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
    scale_y_continuous(limits = c(0, 25), breaks = c(0, 5, 10, 15, 20, 25)) +
  ylab("Number of Spiders") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
  theme(legend.position = "none") +
  annotate(geom = "text", x = 1.5, y = 25, label = ".", color = "black", size = 5)

ggarrange(raw_plot_spiders, 
          poisson_plot_spiders, 
          log_plot_spiders, 
          labels = c("Raw Data", "Poisson Distribution", "Log-Transformed"),
          nrow = 1)
```

The **number of spiders present by site is significantly higher in the urban center** (z = 4.863, df = 1, 20, p < 0.001).

### Number of Spiders by Predictors

```{r spiders_predictors_stats}
# This is one way to look at the overall data, but I think I end up not using this information
models = list(NumSpiders ~ 1,
              NumSpiders ~ log_TotalSub, 
              NumSpiders ~ log_tdr, 
              NumSpiders ~ log_tdh,
              NumSpiders ~ log_TotalSub + log_tdr,
              NumSpiders ~ log_TotalSub + log_tdh,
              NumSpiders ~ log_tdr + log_tdh,
              NumSpiders ~ log_TotalSub + log_tdr + log_tdh)
fits = lapply(models, glm, data = sites, family = "poisson")
modnames = sapply(models, function(ff)deparse(ff[[3]]))
pander(aictab(fits, modname = modnames), caption="Table 1. AICc model selection table for Search Distance to the Focal Web Overall.", split.tables = Inf)
# The top model keeps all 3 variables and no other model is within 2 Model Likelihood Units
summary(glm(NumSpiders ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson))


global <- glm(NumSpiders ~ log_TotalSub + log_tdr + log_tdh, data = sites, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_ns_o <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_ns_o)
out
info <- out[[12]]
#TotalSub (log_TotalSub)
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Highway (log_tdh)
exp(info[2, 1])
exp(info[2, 2])

with(summary(top_model_ns_o), 1 - deviance/null.deviance) # This gives the R squared value
#summary(model.avg(model_dredge, subset = delta <= 2))
#summary(model.avg(model_dredge))
model.sel(model_dredge) #estimates same signs
car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban forest
global <- glm(NumSpiders ~ tree100m + log_TotalSub + log_tdh + log_patch + log_tdr, data = sites_forest, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_ns_f <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_ns_f)
out
info <- out[[12]]
with(summary(top_model_ns_f), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
#car::vif(get.models(model_dredge, 1)[[1]]) #looking for less than 2

# urban center
global <- glm(NumSpiders ~ log_TotalSub + log_tdr + log_tdh + spec_rad + log_patch + road_length_m, data = sites_center, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_ns_c <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_ns_c)
out
info <- out[[12]]
#TotalSub
exp(info[4, 1])
exp(info[4, 2])
#patch_area_km
exp(info[2, 1])
exp(info[2, 2])
#Traffic_Dist_Highway
exp(info[3, 1])
exp(info[3, 2])
#road_length
info[5, 1]
info[5, 2]
with(summary(top_model_ns_c), 1 - deviance/null.deviance) # This gives the R squared value
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 1)[[1]]) # looking for values < 2
```

*Overall*
Coefficients:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)    7.3234     1.1068   6.617 3.67e-11 ***
log_tdh       -1.1932     0.2785  -4.284 1.84e-05 *** **negative**
log_TotalSub  -0.9523     0.1370  -6.952 3.61e-12 *** **negative**

R-squared = 0.5363275

*Urban Forest*
Coefficients:
            Estimate Std. Error z value Pr(>|z|)   
(Intercept)   0.6419     0.2294   2.798  0.00515 **

R-squared = -8.881784e-16

*Urban Center*
Coefficients:
               Estimate Std. Error z value Pr(>|z|)    
(Intercept)   14.516312   2.195703   6.611 3.81e-11 ***
log_patch     -0.618055   0.205145  -3.013 0.002589 **  **negative**
log_tdh       -1.393026   0.286317  -4.865 1.14e-06 *** **negative**
log_TotalSub  -1.331282   0.357971  -3.719 0.000200 *** **negative**
road_length_m -0.025605   0.007753  -3.303 0.000958 *** **negative**

R-squared = 0.7582528

```{r spiders_predictors_overall_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 3.2, 0.03), 
                 log_tdh = mean(sites$log_tdh))
predicted.distance <- augment(top_model_ns_o, 
                              newdata = nd, 
                              se_fit = TRUE)
spiders_plant <- ggplot(sites, aes(x = log_TotalSub, y = log(NumSpiders))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$NumSpiders)) - 2, max(log(sites$NumSpiders)) + 0.1 * diff(range(log(sites$NumSpiders))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Number of Spiders [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(sites$NumSpiders)), label = "***", color = "black", size = 4)

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites$log_TotalSub), 
                 log_tdh = seq(2.7, 5.5, 0.03))
predicted.distance <- augment(top_model_ns_o, 
                              newdata = nd, 
                              se_fit = TRUE)
spiders_tdh <- ggplot(sites, aes(x = log_tdh, y = log(NumSpiders))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites$NumSpiders)) - 2, max(log(sites$NumSpiders)) + 0.1 * diff(range(log(sites$NumSpiders))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Number of Spiders [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites$NumSpiders)), label = "***", color = "black", size = 4)

spiders_plant
spiders_tdh
```

```{r spiders_predictors_center_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 1.8, 0.02), 
                 log_patch = mean(sites_center$log_patch),
                 road_length_m = mean(sites_center$road_length_m),
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_ns_c, 
                              newdata = nd, 
                              se_fit = TRUE)
spiders_center_plant <- ggplot(sites_center, aes(x = log_TotalSub, y = log(NumSpiders))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumSpiders)) - 1, max(log(sites_center$NumSpiders)) + 0.2 * diff(range(log(sites_center$NumSpiders))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Number of Spiders [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_TotalSub)) + diff(range((predicted.distance$log_TotalSub)))/2, y = max(log(sites_center$NumSpiders)), label = "***", color = "black", size = 4) 

# Patch Area
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = seq(4.34, 7.52, 0.025),
                 road_length_m = mean(sites_center$road_length_m),
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_ns_c, 
                              newdata = nd, 
                              se_fit = TRUE)
spiders_center_patch <- ggplot(sites_center, aes(x = log_patch, y = log(NumSpiders))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_patch, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_patch, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumSpiders)) - 1, max(log(sites_center$NumSpiders)) + 0.15 * diff(range(log(sites_center$NumSpiders))))) +  
  theme_classic() +
  xlab("Patch Area [log(mm²)]") +
  ylab("Number of Spiders [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_patch)) + diff(range((predicted.distance$log_patch)))/2, y = max(log(sites_center$NumSpiders)), label = "**", color = "black", size = 4) 

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 road_length_m = mean(sites_center$road_length_m),
                 log_tdh = seq(3.32, 5.42, 0.02))
predicted.distance <- augment(top_model_ns_c, 
                              newdata = nd, 
                              se_fit = TRUE)
spiders_center_tdh <- ggplot(sites_center, aes(x = log_tdh, y = log(NumSpiders))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumSpiders)) - 2, max(log(sites_center$NumSpiders)) + 0.1 * diff(range(log(sites_center$NumSpiders))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Number of Spiders [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(sites_center$NumSpiders)), label = "***", color = "black", size = 4) 

# Road Length
nd <- data.frame(log_TotalSub = mean(sites_center$log_TotalSub), 
                 log_patch = mean(sites_center$log_patch),
                 road_length_m = seq(47, 136, 1),
                 log_tdh = mean(sites_center$log_tdh))
predicted.distance <- augment(top_model_ns_c, 
                              newdata = nd, 
                              se_fit = TRUE)
spiders_center_road <- ggplot(sites_center, aes(x = (road_length_m), y = log(NumSpiders))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (road_length_m), y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = (road_length_m), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(sites_center$NumSpiders)) - 1, max(log(sites_center$NumSpiders)) + 0.1 * diff(range(log(sites_center$NumSpiders))))) +  
  theme_classic() +
  xlab("Total Road Length [m]") +
  ylab("Number of Spiders [log()]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$road_length_m)) + diff(range((predicted.distance$road_length_m)))/2, y = max(log(sites_center$NumSpiders)), label = "***", color = "black", size = 4) 

spiders_center_plant
spiders_center_patch
spiders_center_road
spiders_center_tdh
```

### Number of Spiders by Land

```{r spiders_land_stats}
spiders_land <- glm(NumSpiders ~ Land, data = sites, family = poisson)
summary(spiders_land)
car::Anova(spiders_land, test.statistic = "LR")
comp <- glht(spiders_land, linfct = mcp(Land = "Tukey"))
summary(comp)
```

```{r spiders_land_graph}
sites <- sites %>% 
  mutate(Land = fct_relevel(Land, "Deciduous Forest", 
                            "Woody Wetlands", 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low"))
nd <- data.frame(Land = factor(levels(sites$Land)))
predictions <- augment(spiders_land, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("rate" = ".fitted", "SE" = ".se.fit")
#predictions <- summary(emmeans(spiders_land, ~Land),type = "response")

spiders_land_plot <- ggplot(sites, aes(x = Land, y = NumSpiders)) + 
  geom_jitter(color = "grey", width = 0.1, size = 0.5) +
  geom_point(aes(x = Land, y = rate, color = Land), size = 1, data = predictions) + 
  geom_errorbar(aes(x = Land, 
                  ymin = rate - SE, 
                  ymax = rate + SE, color = Land), data = predictions, inherit.aes = FALSE, width = 0.25, size = 1) +
  theme_classic() +
  scale_color_manual(values = c("Deciduous Forest" = "#1b9e77", "Woody Wetlands" = "#1b9e77", "Urban, High" = "#d95f02", "Urban, Medium" = "#d95f02", "Urban, Low" = "#d95f02")) +
  xlab("Land Cover Class") +
  ylab("Number of Spiders") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) +
  annotate(geom="text", x=1, y=max(sites$NumSpiders), label="A", color="black", size = 3) +
  annotate(geom="text", x=2, y=max(sites$NumSpiders), label="A", color="black", size = 3) +
  annotate(geom="text", x=3, y=max(sites$NumSpiders), label="B", color="black", size = 3) +
  annotate(geom="text", x=4, y=max(sites$NumSpiders), label="B", color="black", size = 3) +
  annotate(geom="text", x=5, y=max(sites$NumSpiders), label="B", color="black", size = 3)

spiders_land_plot_nox <- spiders_land_plot + 
  theme(axis.text.x = element_blank()) + 
  theme(axis.title.x = element_blank())

spiders_land_plot
```

The **number of spiders per site significantly varies** across land cover class (Chi = 31.65, df = 4, p < 0.001).

## Response Variable: Web Distance

### Web Distance by Location

```{r dist_location_stats}
ggarrange(ggplot(web_dist, aes(x = RetreatDist)) +
            geom_density(),
          ggplot(web_dist, aes(x = log(RetreatDist))) +
            geom_density(), ncol = 2)

shapiro.test(web_dist$RetreatDist) # not normal
shapiro.test(log(web_dist$RetreatDist)) # not normal

dist <- glmer(round(RetreatDist, 0) ~ Location * factor(Neighbor) + (1 | ID), data = web_dist, family = poisson)
summary(dist)

dist2 <- lmer(log(RetreatDist) ~ Location * factor(Neighbor) + (1 | ID), data = web_dist)
coefs <- data.frame(coef(summary(dist2)))
coefs$p.z <- 2 * (1 - pnorm(abs(coefs$t.value)))
coefs

# Both methods yield similar results
web_dist %>% 
  group_by(Location) %>% 
  summarize(mean = mean(RetreatDist),
            se = plotrix::std.error(RetreatDist))
```

```{r dist_location_assumptions, echo = FALSE}
# As is, Poisson
test_dist <- augment(dist, data = web_dist)
resid_dist <- ggplot(test_dist, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_dist$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_dist <- ggplot(test_dist, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_dist <- ggplot(test_dist, aes(x = .fitted, y = sqrt(abs(.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_dist <- ggplot(test_dist, aes(.hat, .resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_dist, qq_dist, scaleloc_dist, lev_dist, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)

# Log-transformed, Normal
test_dist2 <- augment(dist2, data = web_dist)
resid_dist2 <- ggplot(test_dist2, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_dist2$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_dist2 <- ggplot(test_dist2, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_dist2 <- ggplot(test_dist2, aes(x = .fitted, y = sqrt(abs(.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_dist2 <- ggplot(test_dist2, aes(.hat, .resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_dist2, qq_dist2, scaleloc_dist2, lev_dist2, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)
```

```{r dist_location_graph, echo = FALSE}
# raw data
raw <- web_dist %>% 
  group_by(Location, Neighbor) %>% 
  summarise(mean = mean(RetreatDist),
            se = plotrix::std.error(RetreatDist))


raw_plot_dist <- ggplot(web_dist, aes(x = Neighbor, y = RetreatDist)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Neighbor, y = mean, color = Location), size = 2, data = raw) +
  geom_line(aes(x = Neighbor, y = mean, group = Location), size = 2, data = raw, color = "grey") +
  geom_errorbar(aes(x= Neighbor, 
                    ymin = mean - se, 
                    ymax = mean + se, 
                    color = Location), data = raw, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 1000), breaks = c(0, 200, 400, 600, 800, 1000)) +
    xlab("Nearest Neighbors") +
    ylab("Distance from Focal Web \nto Neighbor Web [cm]") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10)) +
    theme(legend.position = "none")

# Non-transformed, poisson distribution
variable_names <- list("1" = "Nearest Neighbor",
                       "2" = "2nd Nearest Neighbor")
variable_labeller <- function(variable,value){
  return(variable_names[value])
}
predictions <- expand.grid(Location = levels(factor(web_dist$Location)), Neighbor = levels(factor(web_dist$Neighbor)))
predictions$response <- predict(dist, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_dist_location <- bootMer(dist, myFunc, nsim = 1000)
#saveRDS(bigBoot_dist_location, file = "bootstrapping/bigBoot_dist_location.Rds")
bigBoot_dist_location <- readRDS("bootstrapping/bigBoot_dist_location.Rds")
predSE <- t(apply(bigBoot_dist_location$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]
#predictions2 <- summary(emmeans(dist, ~Location | Neighbor,type = "response"))

poisson_plot_dist <- ggplot(web_dist, aes(x = Neighbor, y = RetreatDist)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Neighbor, y = response, color = Location), size = 2, data = predictions) + 
  geom_line(aes(x = Neighbor, y = response, group = Location), size = 2, data = predictions, color = "grey") +
  geom_errorbar(aes(x = Neighbor, 
                  ymin = response - SE, 
                  ymax = response + SE,
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
  scale_y_continuous(limits = c(0, 1000), breaks = c(0, 200, 400, 600, 800, 1000)) +
  xlab("Nearest Neighbors") +
  ylab("Distance from Focal Web \nto Neighbor Web [cm]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(legend.position = "none")

# Let's look at the log-transformed response variable since that is normal
variable_names <- list("1" = "Nearest Neighbor",
                       "2" = "2nd Nearest Neighbor")
variable_labeller <- function(variable,value){
  return(variable_names[value])
}
predictions <- expand.grid(Location = levels(factor(web_dist$Location)), Neighbor = levels(factor(web_dist$Neighbor)))
predictions$response <- predict(dist2, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_dist_location2 <- bootMer(dist2, myFunc, nsim = 1000)
#saveRDS(bigBoot_dist_location2, file = "bootstrapping/bigBoot_dist_location2.Rds")
bigBoot_dist_location2 <- readRDS("bootstrapping/bigBoot_dist_location2.Rds")
predSE <- t(apply(bigBoot_dist_location2$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]
#predictions2 <- summary(emmeans(dist2, ~Location | Neighbor,type = "response"))

log_plot_dist <- ggplot(web_dist, aes(x = Neighbor, y = (RetreatDist))) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Neighbor, y = exp(response), color = Location), size = 2, data = predictions) + 
  geom_line(aes(x = Neighbor, y = exp(response), group = Location), size = 2, data = predictions, color = "grey") +
  geom_errorbar(aes(x = Neighbor, 
                  ymin = exp(response - SE), 
                  ymax = exp(response + SE),
                  color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
  scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
  scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
  theme_classic() +
  scale_y_continuous(limits = c(0, 1000), breaks = c(0, 200, 400, 600, 800, 1000)) +
  xlab("Nearest Neighbors") +
  ylab("Distance from Focal Web \nto Neighbor Web [cm]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10))

ggarrange(raw_plot_dist, 
          poisson_plot_dist, 
          log_plot_dist, 
          labels = c("Raw Data", "Poisson Distribution", "Log-Transformed"),
          nrow = 1, 
          common.legend = TRUE)
```

Spider neighbors were **significantly closer in the urban center** than the urban forest (z = -5.597, df = 1, 21, p < 0.001). The **second neighbor was always further from the focal web** than the first (z = 14.654, df = 1, 21, p < 0.001), as this is how we defined the first and second neighbor. We also found a **significant interaction between location and neighbor** (z = 9.860, df = 1, 21, p < 0.001) - the distance between the first and second neighbor differed to a higher degree in the urban center than the urban forest.

### Web Distance by Predictors

To look at the predictors, we will restrict to just the nearest neighbor instead of the nearest and second nearest neighbor.

```{r dist_predictors_stats}
#overall
models = list(round(RetreatDist,0) ~ 1,
              round(RetreatDist,0) ~ log_TotalSub,
              round(RetreatDist,0) ~ log_tdr, 
              round(RetreatDist,0) ~ log_tdh,
              round(RetreatDist,0) ~ log_TotalSub + log_tdr,
              round(RetreatDist,0) ~ log_TotalSub + log_tdh,
              round(RetreatDist,0) ~ log_tdr + log_tdh,
              round(RetreatDist,0) ~ log_TotalSub + log_tdr + log_tdh)
fits = lapply(models, glm, data = near, family = "poisson")
modnames = sapply(models, function(ff)deparse(ff[[3]]))
pander(aictab(fits, modname = modnames), caption="Table 1. AICc model selection table for Search Distance to the Focal Web.", split.tables = Inf)

global <- glm(round(RetreatDist, 0) ~ log_TotalSub + log_tdr + log_tdh, data = near, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wd_o <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wd_o)
out
info <- out[[12]]
# TotalSub
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Road
exp(info[2, 1])
exp(info[2, 1])

with(summary(top_model_wd_o), 1 - deviance/null.deviance)
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 5)[[1]]) # looking for less than 2

# Urban Forest
global <- glm(round(RetreatDist, 0) ~ tree100m + log_TotalSub + log_tdr + log_tdh + log_patch, data = near_forest, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wd_f <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wd_f)
out
info <- out[[12]]
#tree100m
info[5, 1]
info[5, 2]
#TotalSub
exp(info[4, 1])
exp(info[4, 2])
#Road
exp(info[3, 1])
exp(info[3, 2])
#Highway
exp(info[2, 1])
exp(info[2, 2])

with(summary(top_model_wd_f), 1 - deviance/null.deviance)
model.sel(model_dredge) #estimates same signs
#summary(model.avg(model_dredge, subset = delta <= 2))
car::vif(get.models(model_dredge, 1)[[1]]) # looking for less than 2

# Urban Center
global <- glm(round(RetreatDist, 0) ~ log_TotalSub + log_tdr + log_tdh + spec_rad + log_patch + road_length_m, data = near_center, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wd_c <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wd_c)
out
info <- out[[12]]
#TotalSub
exp(info[2, 1])
exp(info[2, 2])
#spec_rad
info[4, 1]
info[4, 2]
#road_length_m
info[3, 1]
info[3, 2]

with(summary(top_model_wd_c), 1 - deviance/null.deviance)
model.sel(model_dredge) #estimates same signs
out <- summary(model.avg(model_dredge, subset = delta <= 2))
out
info <- out[[10]]
#TotalSub
exp(info[2, 1])
exp(info[2, 2])
#spec_rad
info[4, 1]
info[4, 2]
#road_length_m
info[3, 1]
info[3, 2]
#log_patch
exp(info[5, 1])
exp(info[5, 2])
car::vif(get.models(model_dredge, 1)[[1]]) # looking for less than 2

# If any value is much greater than 2, this means there is quite a bit of multicollinearity, and we can try removing the variable with the highest vif. Here is the code you would run to accomplish this.

#global2 <- update(global, .~. -spec_rad)
#options(na.action = "na.fail") # Required for dredge to run
#model_dredge <- dredge(global2, beta = "none", evaluate = T, rank = AICc)
#options(na.action = "na.omit") # set back to default
#top_model_wd_c <- get.models(model_dredge, subset = 1)[[1]]
#out <- summary(top_model_wd_c)
#out
#info <- out[[12]]
#car::vif(get.models(model_dredge, 1)[[1]]) 
```

*Overall*
Coefficients:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)   5.38311    0.06200   86.83   <2e-16 ***
log_tdr      -0.18279    0.01024  -17.84   <2e-16 *** **negative**
log_TotalSub  0.57484    0.01653   34.78   <2e-16 *** **positive**

R-squared = 0.3424213

*Urban Forest*
Coefficients:
              Estimate Std. Error z value Pr(>|z|)    
(Intercept)   5.247233   0.253935  20.664  < 2e-16 ***
log_tdh       0.192623   0.045552   4.229 2.35e-05 *** **positive**
log_tdr       0.097475   0.018717   5.208 1.91e-07 *** **positive**
log_TotalSub -0.182147   0.037627  -4.841 1.29e-06 *** **negative**
tree100m      0.007928   0.001747   4.540 5.64e-06 *** **positive**

R-squared = 0.03720731

*Urban Center*
Coefficients:
               Estimate Std. Error z value Pr(>|z|)    
(Intercept)   25.656433   1.978299  12.969   <2e-16 ***
log_TotalSub  -0.949802   0.081234 -11.692   <2e-16 *** **negative**
road_length_m -0.028700   0.001686 -17.019   <2e-16 *** **negative**
spec_rad      -0.116126   0.013624  -8.523   <2e-16 *** **negative**

R-squared = 0.8382736

(conditional average) 
               Estimate Std. Error Adjusted SE z value Pr(>|z|)    
(Intercept)   27.444071   3.180180    3.580799   7.664   <2e-16 ***
log_TotalSub  -1.011887   0.119466    0.136311   7.423   <2e-16 ***
road_length_m -0.028829   0.001723    0.002106  13.691   <2e-16 ***
spec_rad      -0.124872   0.018357    0.021193   5.892   <2e-16 ***
log_patch     -0.152072   0.060123    0.075060   2.026   0.0428 *

```{r dist_predictors_overall_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 3.2, 0.03), 
                 log_tdr = mean(near$log_tdr))
predicted.distance <- augment(top_model_wd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_plant <- ggplot(near, aes(x = log_TotalSub, y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near$RetreatDist)), max(log(near$RetreatDist)) + 0.1 * diff(range(log(near$RetreatDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(near$RetreatDist)), label = "***", color = "black", size = 4)

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(near$log_TotalSub), 
                 log_tdr = seq(2.7, 7.3, 0.05))
predicted.distance <- augment(top_model_wd_o, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_tdr <- ggplot(near, aes(x = log_tdr, y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = coloro, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = coloro, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near$RetreatDist)), max(log(near$RetreatDist)) + 0.1 * diff(range(log(near$RetreatDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(near$RetreatDist)), label = "***", color = "black", size = 4)

dist_plant
dist_tdr
```

```{r dist_predictors_forest_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(1.94, 3.14, 0.015), 
                 log_tdr = mean(near_forest$log_tdr),
                 log_tdh = mean(near_forest$log_tdh),
                 tree100m = mean(near_forest$tree100m))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_forest_plant <- ggplot(near_forest, aes(x = log_TotalSub, y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_forest$RetreatDist)), max(log(near_forest$RetreatDist)) + 0.1 * diff(range(log(near_forest$RetreatDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(near_forest$RetreatDist)), label = "***", color = "black", size = 4)

# Highway Disturbance
nd <- data.frame(log_TotalSub = mean(near_forest$log_TotalSub), 
                 log_tdr = mean(near_forest$log_tdr),
                 log_tdh = seq(2.76, 3.89, 0.01),
                 tree100m = mean(near_forest$tree100m))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_forest_tdh <- ggplot(near_forest, aes(x = log_tdh, y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdh, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdh, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_forest$RetreatDist)), max(log(near_forest$RetreatDist)) + 0.1 * diff(range(log(near_forest$RetreatDist))))) +  
  theme_classic() +
  xlab("Highway Disturbance [log(vehicles/day/m)]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdh)) + diff(range((predicted.distance$log_tdh)))/2, y = max(log(near_forest$RetreatDist)), label = "***", color = "black", size = 4)

# Road Disturbance
nd <- data.frame(log_TotalSub = mean(near_forest$log_TotalSub), 
                 log_tdr = seq(2.73, 6.22, 0.04),
                 log_tdh = mean(near_forest$log_tdh),
                 tree100m = mean(near_forest$tree100m))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_forest_tdr <- ggplot(near_forest, aes(x = log_tdr, y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_forest$RetreatDist)), max(log(near_forest$RetreatDist)) + 0.1 * diff(range(log(near_forest$RetreatDist))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$log_tdr)) + diff(range((predicted.distance$log_tdr)))/2, y = max(log(near_forest$RetreatDist)), label = "***", color = "black", size = 4)

# Tree
nd <- data.frame(log_TotalSub = mean(near_forest$log_TotalSub), 
                 log_tdr = mean(near_forest$log_tdr),
                 log_tdh = mean(near_forest$log_tdh),
                 tree100m = seq(31.37, 65.87, 0.35))
predicted.distance <- augment(top_model_wd_f, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_forest_tree <- ggplot(near_forest, aes(x = (tree100m), y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (tree100m), y = .fitted), 
            size = 1, 
            color = colorf, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log(tree100m), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorf, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_forest$RetreatDist)), max(log(near_forest$RetreatDist)) + 0.1 * diff(range(log(near_forest$RetreatDist))))) +  
  theme_classic() +
  xlab("Percent Tree Cover [%]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$tree100m)) + diff(range((predicted.distance$tree100m)))/2, y = max(log(near_forest$RetreatDist)), label = "***", color = "black", size = 4)

dist_forest_plant
dist_forest_tdr
dist_forest_tdh
dist_forest_tree
```

```{r dist_predictors_center_graphs, echo = FALSE}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
nd <- data.frame(log_TotalSub = seq(0, 1.8, 0.02), 
                 spec_rad = mean(near_center$spec_rad),
                 road_length_m = mean(near_center$road_length_m))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_center_plant <- ggplot(near_center, aes(x = log_TotalSub, y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_center$RetreatDist)), max(log(near_center$RetreatDist)) + 0.1 * diff(range(log(near_center$RetreatDist))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predicted.distance$log_TotalSub) + diff(range(predicted.distance$log_TotalSub))/2, y = max(log(near_center$RetreatDist)), label = "***", color = "black", size = 4)

# Spectral Radiance
nd <- data.frame(log_TotalSub = mean(near_center$log_TotalSub), 
                 spec_rad = seq(149, 163, 0.15),
                 road_length_m = mean(near_center$road_length_m))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_center_spec <- ggplot(near_center, aes(x = (spec_rad), y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (spec_rad), y = .fitted), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = (spec_rad), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_center$RetreatDist)), max(log(near_center$RetreatDist)) + 0.1 * diff(range(log(near_center$RetreatDist))))) +  
  theme_classic() +
  xlab("Spectral Radiance \n[Watts/(m² * sr * µm)]") + 
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$spec_rad)) + diff(range((predicted.distance$spec_rad)))/2, y = max(log(near_center$RetreatDist)), label = "***", color = "black", size = 4)

# Road Length
nd <- data.frame(log_TotalSub = mean(near_center$log_TotalSub), 
                 spec_rad = mean(near_center$spec_rad),
                 road_length_m = seq(47, 117, 0.6))
predicted.distance <- augment(top_model_wd_c, 
                              newdata = nd, 
                              se_fit = TRUE)
dist_center_road <- ggplot(near_center, aes(x = (road_length_m), y = log(RetreatDist))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = (road_length_m), y = (.fitted)), 
            size = 1, 
            color = colorc, 
            data = predicted.distance) + 
  geom_ribbon(aes(x = (road_length_m), 
                  ymin = .fitted - 1.96 * .se.fit, 
                  ymax = .fitted + 1.96 * .se.fit), 
              fill = colorc, 
              data = predicted.distance, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(near_center$RetreatDist)), max(log(near_center$RetreatDist)) + 0.1 * diff(range(log(near_center$RetreatDist))))) +  
  theme_classic() +
  xlab("Total Road Length [m]") +
  ylab("Distance from Focal Web \nto Neighbor Web [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predicted.distance$road_length_m)) + diff(range((predicted.distance$road_length_m)))/2, y = max(log(near_center$RetreatDist)), label = "***", color = "black", size = 4)

dist_center_plant
dist_center_spec
dist_center_road
```

### Web Distance by Land

```{r dist_land_stats}
dist_land <- glm(round(RetreatDist, 0) ~ Land, data = near, family = poisson)
summary(dist_land)
car::Anova(dist_land, test.statistic = "LR")
comp <- glht(dist_land, linfct = mcp(Land = "Tukey"))
summary(comp)
```

```{r dist_land_graph}
near <- near %>% 
  mutate(Land = fct_relevel(Land, "Deciduous Forest", 
                            "Woody Wetlands", 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low"))
nd <- data.frame(Land = factor(levels(sites$Land)))
predictions <- augment(dist_land, newdata = nd, se_fit = TRUE, type.predict = "response")
predictions <- predictions %>% 
  rename("response" = ".fitted", "SE" = ".se.fit")
#predictions <- summary(emmeans(dist_land, ~Land),type = "response")

dist_land_plot <- ggplot(near, aes(x = Land, y = RetreatDist)) + 
  geom_jitter(color = "grey", width = 0.1, size = 0.5) +
  geom_point(aes(x = Land, y = response, color = Land), size = 1, data = predictions) + 
  geom_errorbar(aes(x = Land, 
                  ymin = response - SE, 
                  ymax = response + SE, color = Land), data = predictions, inherit.aes = FALSE, width = 0.25, size = 1) +
  theme_classic() +
  scale_color_manual(values = c("Deciduous Forest" = "#1b9e77", "Woody Wetlands" = "#1b9e77", "Urban, High" = "#d95f02", "Urban, Medium" = "#d95f02", "Urban, Low" = "#d95f02")) +
  xlab("Land Cover Class") +
  ylab("Distance from Focal \nWeb to Neighbor Web (cm)") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) +
  annotate(geom="text", x=1, y=max(near$RetreatDist), label="A", color="black", size = 3) +
  annotate(geom="text", x=2, y=max(near$RetreatDist), label="B", color="black", size = 3) +
  annotate(geom="text", x=3, y=max(near$RetreatDist), label="C", color="black", size = 3) +
  annotate(geom="text", x=4, y=max(near$RetreatDist), label="D", color="black", size = 3) +
  annotate(geom="text", x=5, y=max(near$RetreatDist), label="E", color="black", size = 3)

dist_land_plot
```

**Distance between webs significantly varies** by land cover class (Chi = 3629.3, df = 4, p < 0.001). 

## Response Variable: Web Height

### Web Height by Location

```{r height_location_stats}
webs$RetreatHeight[webs$RetreatHeight == 0] <- 0.1
ggarrange(ggplot(webs, aes(x = RetreatHeight)) +
            geom_density(),
          ggplot(webs, aes(x = log(RetreatHeight))) +
            geom_density(), ncol = 2)

shapiro.test(webs$RetreatHeight) # not normal
shapiro.test(log(webs$RetreatHeight)) # not normal

height <- glmer(round(RetreatHeight, 0) ~ Location + (1 | ID), data = webs, family = poisson)
summary(height)
height2 <- lmer(log(RetreatHeight) ~ Location + (1 | ID), data = webs)
summary(height2)
```

```{r height_location_assumptions, echo = FALSE}
# As is, Poisson
test_height <- augment(height, data = webs)
resid_height <- ggplot(test_height, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_height$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_height <- ggplot(test_height, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_height <- ggplot(test_height, aes(x = .fitted, y = sqrt(abs(.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_height <- ggplot(test_height, aes(.hat, .resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_height, qq_height, scaleloc_height, lev_height, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)

# Log-transformed, Normal
test_height2 <- augment(height2, data = webs)
resid_height2 <- ggplot(test_height2, aes(x = .fitted, y = .resid)) + 
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0) +
  xlab("Fitted Values") +
  ylab("Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))

y <- quantile(test_height2$.resid, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

qq_height2 <- ggplot(test_height2, aes(sample = .resid)) + 
  stat_qq() + 
  geom_abline(slope = slope, intercept = int) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

scaleloc_height2 <- ggplot(test_height2, aes(x = .fitted, y = sqrt(abs(.resid)))) + 
  geom_point() + 
  geom_smooth() + 
  geom_hline(yintercept = 0.83) +
  xlab("Fitted Values") +
  ylab("Sqrt Standardized \nResiduals") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14))  

lev_height2 <- ggplot(test_height2, aes(.hat, .resid)) +
 geom_vline(colour = "black", xintercept = 0) +
  geom_hline(colour = "black", yintercept = 0) +
  geom_point(aes(size = .cooksd)) + geom_smooth(se = FALSE) +
  xlab("Theoretical Quantiles") +
  ylab("Sample Quantiles") +
  labs(size = "Cook's \nDistance") +
  theme_classic() +
  theme(text = element_text(size = 14, color = "black")) +
  theme(axis.text.x=element_text(color="black", size=14)) + 
  theme(axis.text.y=element_text(color="black", size=14)) 

ggarrange(resid_height2, qq_height2, scaleloc_height2, lev_height2, 
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)
```

```{r height_location_graph, echo = FALSE}
# raw data
raw <- webs %>% 
  group_by(Location) %>% 
  summarise(mean = mean(RetreatHeight),
            se = plotrix::std.error(RetreatHeight))


raw_plot_height <- ggplot(webs, aes(x = Location, y = RetreatHeight)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = mean, color = Location), size = 2, data = raw) +
  geom_errorbar(aes(x= Location, 
                    ymin = mean - se, 
                    ymax = mean + se, 
                    color = Location), data = raw, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 210), breaks = c(0, 35, 70, 105, 140, 175, 210)) +
    ylab("Web Height [cm]") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
    theme(legend.position = "none")

# Non-transformed, poisson distribution
predictions <- expand.grid(Location = levels(factor(webs$Location)))
predictions$response <- predict(height, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_location <- bootMer(height, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_location, file = "bootstrapping/bigBoot_height_location.Rds")
bigBoot_height_location <- readRDS("bootstrapping/bigBoot_height_location.Rds")
predSE <- t(apply(bigBoot_height_location$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]
#predictions2 <- summary(emmeans(height, ~Location | Neighbor,type = "response"))

poisson_plot_height <- ggplot(webs, aes(x = Location, y = RetreatHeight)) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = response, color = Location), size = 2, data = predictions) +
  geom_errorbar(aes(x= Location, 
                    ymin = response - SE, 
                    ymax = response + SE, 
                    color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 210), breaks = c(0, 35, 70, 105, 140, 175, 210)) +
    ylab("Web Height [cm]") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
    theme(legend.position = "none") +
    annotate(geom = "text", x = 1.5, y = 210, label = "*", color = "black", size = 5)


# Let's look at the log-transformed response variable since that is normal
predictions <- expand.grid(Location = levels(factor(webs$Location)))
predictions$response <- predict(height2, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_location2 <- bootMer(height2, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_location2, file = "bootstrapping/bigBoot_height_location2.Rds")
bigBoot_height_location2 <- readRDS("bootstrapping/bigBoot_height_location2.Rds")
predSE <- t(apply(bigBoot_height_location2$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]
#predictions2 <- summary(emmeans(height2, ~Location | Neighbor,type = "response"))

log_plot_height <- ggplot(webs, aes(x = Location, y = (RetreatHeight))) + 
  geom_jitter(color = "grey", width = 0.1) +
  geom_point(aes(x = Location, y = exp(response), color = Location), size = 2, data = predictions) +
  geom_errorbar(aes(x= Location, 
                    ymin = exp(response - SE), 
                    ymax = exp(response + SE), 
                    color = Location), data = predictions, inherit.aes = FALSE, width = 0.15, size = 1.5) +
    scale_color_manual(values = c("Urban Center" = "#d95f02", "Urban Forest" = "#1b9e77")) +
    scale_x_discrete(labels=c("Urban Forest" = "Urban \nForest \nN = 10", "Urban Center" = "Urban \nCenter \nN = 12")) +
    theme_classic() +
    scale_y_continuous(limits = c(0, 210), breaks = c(0, 35, 70, 105, 140, 175, 210)) +
    ylab("Web Height [cm]") + 
    theme(text = element_text(size = 10)) + 
    theme(axis.text.x = element_text(colour = "black", size = 10)) + 
    theme(axis.text.y = element_text(colour = "black", size = 10),
        axis.title.x = element_blank()) +
    theme(legend.position = "none") +
    annotate(geom = "text", x = 1.5, y = 210, label = "*", color = "black", size = 5)

ggarrange(raw_plot_height, 
          poisson_plot_height, 
          log_plot_height, 
          labels = c("Raw Data", "Poisson Distribution", "Log-Transformed"),
          nrow = 1, 
          common.legend = TRUE)
```

**Webs are significantly higher in the urban forest** than the urban center (z = -2.384, df = 1, 21, p = 0.017). 

### Web Height by Predictors

```{r height_predictors_stats}
#overall
models = list(ceiling(RetreatHeight) ~ 1,
              ceiling(RetreatHeight) ~ log_TotalSub,
              ceiling(RetreatHeight) ~ log_tdr, 
              ceiling(RetreatHeight) ~ log_tdh,
              ceiling(RetreatHeight) ~ log_TotalSub + log_tdr,
              ceiling(RetreatHeight) ~ log_TotalSub + log_tdh,
              ceiling(RetreatHeight) ~ log_tdr + log_tdh,
              ceiling(RetreatHeight) ~ log_TotalSub + log_tdr + log_tdh)
fits = lapply(models, glm, data = webs, family = "poisson")
modnames = sapply(models, function(ff)deparse(ff[[3]]))
pander(aictab(fits, modname = modnames), caption="Table 1. AICc model selection table for Search Distance to the Focal Web.", split.tables = Inf)

global <- glmer(round(RetreatHeight, 0) ~ log_TotalSub + log_tdr + log_tdh + (1 | ID), data = webs, family = poisson)
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = TRUE, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wh_o <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wh_o)
out
info <- out[[10]]
# TotalSub
exp(info[3, 1])
exp(info[3, 2])
#Traffic_Dist_Road
exp(info[2, 1])
exp(info[2, 1])

r.squaredGLMM(top_model_wh_o) 
model.sel(model_dredge) #estimates same signs
out <- summary(model.avg(model_dredge, subset = delta <= 2))
out
info <- out[[10]]
#tdr
exp(info[2, 1])
exp(info[2, 2])
#TotalSub
exp(info[3, 1])
exp(info[3, 2])
#tdh
exp(info[4, 1])
exp(info[4, 2])
car::vif(get.models(model_dredge, 5)[[1]]) # looking for less than 2

# Urban Forest
webs_forest <- webs_forest %>% 
  mutate(tree100m_frac = I(tree100m/100))
global <- glmer(round(RetreatHeight, 0) ~ tree100m_frac + log_TotalSub + log_tdr + log_tdh + log_patch + (1 | ID), data = webs_forest, family = poisson, control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e4)))
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = TRUE, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wh_f <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wh_f)
out
info <- out[[10]]

#tree
exp(info[2, 1])
exp(info[2, 2])

r.squaredGLMM(top_model_wh_f) 
model.sel(model_dredge) #estimates same signs
out <- summary(model.avg(model_dredge, subset = delta <= 2))
out
info <- out[[10]]
#tree
exp(info[2, 1])
exp(info[2, 2])
#TotalSub
exp(info[3, 1])
exp(info[3, 2])
#tdr
exp(info[4, 1])
exp(info[4, 2])

#car::vif(get.models(model_dredge, 1)[[1]]) # looking for less than 2

# Urban Center
global <- glmer(round(RetreatHeight, 0) ~ log_TotalSub + log_tdr + log_tdh + scale(spec_rad, center = FALSE) + log_patch + scale(road_length_m, center = FALSE) + (1 | ID), data = webs_center, family = poisson,  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e4)))
options(na.action = "na.fail") # Required for dredge to run
model_dredge <- dredge(global, beta = "none", evaluate = T, rank = AICc)
options(na.action = "na.omit") # set back to default
top_model_wh_c <- get.models(model_dredge, subset = 1)[[1]]
out <- summary(top_model_wh_c)
out
info <- out[[10]]
#TotalSub
exp(info[2, 1])
exp(info[2, 2])

r.squaredGLMM(top_model_wh_c) 
model.sel(model_dredge) #estimates same signs
out <- summary(model.avg(model_dredge, subset = delta <= 2))
out
info <- out[[10]]
#TotalSub
exp(info[2, 1])
exp(info[2, 2])
#road length
exp(info[3, 1])
exp(info[3, 2])
#tdh
exp(info[4, 1])
exp(info[4, 2])
#tdr
exp(info[5, 1])
exp(info[5, 2])
#patch
exp(info[6, 1])
exp(info[6, 2])
#spec_rad
exp(info[7, 1])
exp(info[7, 2])
#car::vif(get.models(model_dredge, 1)[[1]]) # looking for less than 2
```

*Overall* 
Fixed effects:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)    3.1686     0.6215   5.098 3.43e-07 ***
log_tdr       -0.1896     0.1023  -1.854  0.06378 .   **negative**
log_TotalSub   0.4812     0.1659   2.901  0.00372 **  **positive**

R-squared = 0.3671774 (marginal - fixed) 0.9521663 (conditional - fixed and random)

(conditional average) 
             Estimate Std. Error Adjusted SE z value Pr(>|z|)   
(Intercept)    3.3701     1.2954      1.3012   2.590  0.00959 **
log_tdr       -0.1986     0.1022      0.1032   1.924  0.05432 .  
log_TotalSub   0.4697     0.1814      0.1830   2.567  0.01026 * 
log_tdh       -0.3307     0.2719      0.2745   1.205  0.22832    

*Urban Forest*
Fixed effects:
              Estimate Std. Error z value Pr(>|z|)   
(Intercept)     1.1283     0.8355   1.350  0.17687   
tree100m_frac   5.0864     1.7266   2.946  0.00322 ** **positive**

R-squared = 0.4787743 (marginal - fixed) 0.9596909 (conditional - fixed and random)

(conditional average) 
              Estimate Std. Error Adjusted SE z value Pr(>|z|)   
(Intercept)     0.3764     1.3417      1.3881   0.271   0.7863   
tree100m_frac   5.0033     1.7056      1.7823   2.807   0.0050 **
log_TotalSub    0.6815     0.3801      0.3976   1.714   0.0865 . 
log_tdr        -0.2415     0.1683      0.1769   1.365   0.1721 

*Urban Center*
Fixed effects:
             Estimate Std. Error z value Pr(>|z|)    
(Intercept)    2.0705     0.4687   4.417    1e-05 ***
log_TotalSub   0.6449     0.3921   1.645      0.1     **positive**

R-squared = 0.1332201 (marginal - fixed) 0.9103755 (conditional - fixed and random)

(conditional average) 
                                     Estimate Std. Error Adjusted SE z value Pr(>|z|)  
(Intercept)                            2.6980     2.7479      2.7626   0.977   0.3288  
log_TotalSub                           0.7725     0.4093      0.4138   1.867   0.0619 .
scale(road_length_m, center = FALSE)   1.0413     0.7533      0.7625   1.366   0.1720  
log_tdh                               -0.3763     0.3175      0.3212   1.172   0.2413  
log_tdr                               -0.2307     0.1466      0.1483   1.555   0.1199  
log_patch                              0.2033     0.1934      0.1959   1.038   0.2994  
scale(spec_rad, center = FALSE)       -5.6099     6.2722      6.3531   0.883   0.3772

```{r height_predictor_overall_graphs}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
predictions <- expand.grid(log_TotalSub = seq(0, 3.15, 0.03),
                           log_tdr = mean(webs$log_tdr))
predictions$response <- predict(top_model_wh_o, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_overall_plant <- bootMer(top_model_wh_o, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_overall_plant, file = "bootstrapping/bigBoot_height_overall_plant.Rds")
bigBoot_height_overall_plant <- readRDS("bootstrapping/bigBoot_height_overall_plant.Rds")
predSE <- t(apply(bigBoot_height_overall_plant$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

height_plant <- ggplot(webs, aes(x = log_TotalSub, y = log(RetreatHeight))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = log(response)), 
            size = 1, 
            color = coloro, 
            data = predictions) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = log(response - 1.96 * SE), 
                  ymax = log(response + 1.96 * SE)), 
              fill = coloro, 
              data = predictions, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(webs$RetreatHeight)), max(log(webs$RetreatHeight)) + 0.1 * diff(range(log(webs$RetreatHeight))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Web Height [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predictions$log_TotalSub) + diff(range(predictions$log_TotalSub))/2, y = max(log(webs$RetreatHeight)), label = "**", color = "black", size = 4)

# Road Disturbance
predictions <- expand.grid(log_TotalSub = mean(webs$log_TotalSub),
                           log_tdr = seq(2.73, 7.22, 0.05))
predictions$response <- predict(top_model_wh_o, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_overall_tdr <- bootMer(top_model_wh_o, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_overall_tdr, file = "bootstrapping/bigBoot_height_overall_tdr.Rds")
bigBoot_height_overall_tdr <- readRDS("bootstrapping/bigBoot_height_overall_tdr.Rds")
predSE <- t(apply(bigBoot_height_overall_tdr$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

height_tdr <- ggplot(webs, aes(x = log_tdr, y = log(RetreatHeight))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_tdr, y = log(response)), 
            size = 1, 
            color = coloro, 
            data = predictions) + 
  geom_ribbon(aes(x = log_tdr, 
                  ymin = log(response - 1.96 * SE), 
                  ymax = log(response + 1.96 * SE)), 
              fill = coloro, 
              data = predictions, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(webs$RetreatHeight)), max(log(webs$RetreatHeight)) + 0.1 * diff(range(log(webs$RetreatHeight))))) +  
  theme_classic() +
  xlab("Road Disturbance [log(vehicles/day/m)]") +
  ylab("Web Height [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(predictions$log_tdr) + diff(range(predictions$log_tdr))/2, y = max(log(webs$RetreatHeight)), label = "N. S.", color = "black", size = 4)

height_plant
height_tdr
```

```{r height_predictor_forest_graphs}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Tree
predictions <- expand.grid(tree100m_frac = seq(0.31, 0.66, 0.003))
predictions$response <- predict(top_model_wh_f, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_forest_tree <- bootMer(top_model_wh_f, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_forest_tree, file = "bootstrapping/bigBoot_height_forest_tree.Rds")
bigBoot_height_forest_tree <- readRDS("bootstrapping/bigBoot_height_forest_tree.Rds")
predSE <- t(apply(bigBoot_height_forest_tree$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

height_forest_tree <- ggplot(webs_forest, aes(x = log(tree100m_frac), y = log(RetreatHeight))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log(tree100m_frac), y = log(response)), 
            size = 1, 
            color = colorf, 
            data = predictions) + 
  geom_ribbon(aes(x = log(tree100m_frac), 
                  ymin = log(response - 1.96 * SE), 
                  ymax = log(response + 1.96 * SE)), 
              fill = colorf, 
              data = predictions, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(webs_forest$RetreatHeight)), max(log(webs_forest$RetreatHeight)) + 0.1 * diff(range(log(webs_forest$RetreatHeight))))) +  
  theme_classic() +
  xlab("Proportion of Tree Cover in 100-Meter Buffer of Site [log()]") +
  ylab("Web Height [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min(log(predictions$tree100m_frac)) + diff(range(log(predictions$tree100m_frac)))/2, y = max(log(webs_forest$RetreatHeight)), label = "**", color = "black", size = 4)

height_forest_tree
```

```{r height_predictor_center_graphs}
colorc = "#d95f02" 
colorf = "#1b9e77"
coloro = "black"

# Plant Species Richness
predictions <- expand.grid(log_TotalSub = seq(0, 1.80, 0.02))
predictions$response <- predict(top_model_wh_c, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_center_plant <- bootMer(top_model_wh_c, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_center_plant, file = "bootstrapping/bigBoot_height_center_plant.Rds")
bigBoot_height_center_plant <- readRDS("bootstrapping/bigBoot_height_center_plant.Rds")
predSE <- t(apply(bigBoot_height_center_plant$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]

height_center_plant <- ggplot(webs_center, aes(x = log_TotalSub, y = log(RetreatHeight))) + 
  geom_point(color = "grey", 
             size = 1) +
  geom_line(aes(x = log_TotalSub, y = log(response)), 
            size = 1, 
            color = colorc, 
            data = predictions) + 
  geom_ribbon(aes(x = log_TotalSub, 
                  ymin = log(response - 1.96 * SE), 
                  ymax = log(response + 1.96 * SE)), 
              fill = colorc, 
              data = predictions, 
              inherit.aes = FALSE, 
              alpha = 0.25) +
  scale_y_continuous(limits = c(min(log(webs_forest$RetreatHeight)) - 4, max(log(webs_forest$RetreatHeight)) + 0.1 * diff(range(log(webs_forest$RetreatHeight))))) +  
  theme_classic() +
  xlab("Plant Species Richness [log()]") +
  ylab("Web Height [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x = element_text(colour = "black", size = 10)) + 
  theme(axis.text.y = element_text(colour = "black", size = 10)) +
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank()) +
  annotate(geom = "text", x = min((predictions$log_TotalSub)) + diff(range((predictions$log_TotalSub)))/2, y = max(log(webs_forest$RetreatHeight)), label = "N.S.", color = "black", size = 4)

height_center_plant
```

### Web Height by Land

```{r height_land_stats}
height_land <- glmer(round(RetreatHeight, 0) ~ Land + (1 | ID), data = webs, family = poisson)
summary(height_land)
car::Anova(height_land, type = 3)
comp <- glht(height_land, linfct = mcp(Land = "Tukey"))
summary(comp)
```

```{r height_land_graph}
webs <- webs %>% 
  mutate(Land = fct_relevel(Land, "Deciduous Forest", 
                            "Woody Wetlands", 
                            "Urban, High", 
                            "Urban, Medium", 
                            "Urban, Low"))
predictions <- expand.grid(Land = levels(factor(webs$Land)))
predictions$response <- predict(height_land, newdata = predictions, se.fit = TRUE, re.form = NA, type = "response")

myFunc <- function(mm) {
    predict(mm, newdata = predictions, re.form = ~0, type = "response")
}
#bigBoot_height_land <- bootMer(height_land, myFunc, nsim = 1000)
#saveRDS(bigBoot_height_land, file = "bootstrapping/bigBoot_height_land.Rds")
bigBoot_height_land <- readRDS("bootstrapping/bigBoot_height_land.Rds")
predSE <- t(apply(bigBoot_height_land$t, MARGIN = 2, FUN = sd))
predictions$SE <- predSE[1, ]
#predictions2 <- summary(emmeans(height_land, ~Land,type = "response"))

height_land_plot <- ggplot(webs, aes(x = Land, y = RetreatHeight)) + 
  geom_jitter(color = "grey", width = 0.1, size = 0.5) +
  geom_point(aes(x = Land, y = response, color = Land), size = 1, data = predictions) + 
  geom_errorbar(aes(x = Land, 
                  ymin = response - SE, 
                  ymax = response + SE, color = Land), data = predictions, inherit.aes = FALSE, width = 0.25, size = 1) +
  theme_classic() +
  scale_color_manual(values = c("Deciduous Forest" = "#1b9e77", "Woody Wetlands" = "#1b9e77", "Urban, High" = "#d95f02", "Urban, Medium" = "#d95f02", "Urban, Low" = "#d95f02")) +
  xlab("Land Cover Class") +
  ylab("Web Height [log(cm)]") + 
  theme(text = element_text(size = 10)) + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) +
  annotate(geom="text", x=1, y=max(webs$RetreatHeight), label="A", color="black", size = 3) +
  annotate(geom="text", x=2, y=max(webs$RetreatHeight), label="A", color="black", size = 3) +
  annotate(geom="text", x=3, y=max(webs$RetreatHeight), label="A", color="black", size = 3) +
  annotate(geom="text", x=4, y=max(webs$RetreatHeight), label="A", color="black", size = 3) +
  annotate(geom="text", x=5, y=max(webs$RetreatHeight), label="A", color="black", size = 3)

height_land_plot
```

**Web height varies significantly** across land cover class (chi = 10.495, df = 4, p = 0.033). 

## Figures for Manuscript

### Measurement by Location Figure

```{r main}
blankPlot <- ggplot() + 
  geom_blank(aes(1,1)) + 
  cowplot::theme_nothing()

main_row1 <- ggarrange(poisson_plot_search, poisson_plot_webs, poisson_plot_spiders, labels = c("a", "b", "c"), nrow = 1, font.label = list(size = 10))
main_row2 <- ggarrange(poisson_plot_dist, poisson_plot_height, blankPlot, labels = c("d", "e", ""), nrow = 1, font.label = list(size = 10))
main <- ggarrange(main_row1, main_row2, nrow = 2, font.label = list(size = 10))

#saveRDS(main, "manuscript/figures/main.Rds")
```

### Predictors of Web and Spider Abundance

```{r predictors_abund}
webs_text <- as_ggplot(text_grob(paste("Number of \nWebs \n[log()]"), size = 10))
spiders_text <- as_ggplot(text_grob(paste("Number of \nSpiders \n[log()]"), size = 10))
plant_text <- as_ggplot(text_grob(paste("Plant Species \nRichness \n[log()]"), size = 10))
patch_text <-as_ggplot(text_grob(paste("Patch Area \n[log(km²)]"), size = 10))
highway_text <- as_ggplot(text_grob(paste("Highway Disturb. \n[log(cars/\nday/m)]"), size = 10))
rlength_text <- as_ggplot(text_grob(paste("Road \nLength [m]"), size = 10))
blankPlot <- ggplot()+geom_blank(aes(1,1)) + 
  cowplot::theme_nothing() 

pa <- ggarrange(webs_text, webs_center_plant, webs_center_patch, webs_center_tdh, webs_center_road,
           spiders_text, spiders_center_plant, spiders_center_patch, spiders_center_tdh, spiders_center_road,
          ncol = 5, nrow = 2, widths = c(0.1, 0.225, 0.225, 0.225, 0.225))

labels <- ggarrange(blankPlot, plant_text, patch_text, highway_text, rlength_text, ncol = 5, nrow = 1, widths = c(0.1, 0.225, 0.225, 0.225, 0.225))

predictors_abund <- ggarrange(pa, labels, nrow = 2, heights = c(0.8, 0.2))
#saveRDS(predictors_abund, "manuscript/figures/predictors_abund.Rds")
```

### Predictors of Aggregation

```{r predictors_agg}
wd_text1 <- as_ggplot(text_grob(paste("Forest \nNearest \nNeighbor \nDist. [log(cm)]"), size = 10))
wd_text2 <- as_ggplot(text_grob(paste("Center \nNearest \nNeighbor \nDist. [log(cm)]"), size = 10))
tree_text <- as_ggplot(text_grob(paste("Tree Cover [%]"), size = 10))
plant_text <- as_ggplot(text_grob(paste("Plant Species \nRichness \n[log()]"), size = 10))
road_text <- as_ggplot(text_grob(paste("Road Disturb. \n[log(cars/day/m)]"), size = 10))
highway_text <- as_ggplot(text_grob(paste("Highway Disturb. \n[log(cars/day/m)]"), size = 10))
spec_text <- as_ggplot(text_grob(paste("Spectral \nRadiance \n[Watts/(m²*sr*µm)]"), size = 10))
rlength_text <- as_ggplot(text_grob(paste("Road \nLength [m]"), size = 10))
blankPlot <- ggplot()+geom_blank(aes(1,1)) + 
  cowplot::theme_nothing() 

agg1 <- ggarrange(wd_text1, dist_forest_plant, dist_forest_tree, dist_forest_tdr, dist_forest_tdh,
          ncol = 5, nrow = 1, widths = c(0.12, 0.22, 0.22, 0.22, 0.22))

agg2 <- ggarrange(wd_text2, dist_center_plant, dist_center_spec, dist_center_road, blankPlot,
          ncol = 5, nrow = 1, widths = c(0.12, 0.22, 0.22, 0.22, 0.22))

labels1 <- ggarrange(blankPlot, plant_text, tree_text, road_text, highway_text, ncol = 5, nrow = 1, widths = c(0.1, 0.225, 0.225, 0.225, 0.225))

labels2 <- ggarrange(blankPlot, plant_text, spec_text, rlength_text, blankPlot, ncol = 5, nrow = 1, widths = c(0.1, 0.225, 0.225, 0.225, 0.225))

predictors_agg <- ggarrange(agg1, labels1, agg2, labels2, nrow = 4, heights = c(0.35, 0.15, 0.35, 0.15))
#saveRDS(predictors_agg, "manuscript/figures/predictors_agg.Rds")
```

## Tables for Manuscript

### Landscape Features by Location

```{r landscape_table}
rownames(land_cover) <- c("Area (sq. km)", "Tree Cover (%)", "Impervious Cover (%)", "Urban Cover (%)", "Urban, High Intensity (%)", "Urban, Medium Intensity (%)", "Urban, low Intensity (%)", "Urban, Open Space (%)", "Forest Cover (%)", "Deciduous Forest (%)", "Mixed Forest (%)", "Evergreen Forest (%)", "Woody Wetlands (%)", "Other Cover (%)", "Herbaceous Wetlands (%)", "Grassland Herbaceous (%)", "Pasture (%)", "Cultivated Crop (%)", "Open Water (%)")
names <- rownames(land_cover)
rownames(land_cover) <- seq(1:nrow(land_cover))
land_cover <- cbind(names, land_cover)
colnames(land_cover) <- c(" ", "Lincoln City Limits", "UNL City Campus \nUrban Center", "Wilderness Park \nUrban Forest")
flextable(land_cover[ ,1:4]) %>% 
  autofit() %>% 
  hline(i = c("3", "4", "8", "9", "13", "14"), part = "body") %>% 
  bg(i = c("4", "9", "14"), bg = "grey95") %>% 
  bold(bold = TRUE, part = "header") %>% 
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  set_caption("") %>% 
  save_as_image(path = here::here("manuscript/figures/landscape.png"))
```

### Predictors by Location

```{r pred_location, fig.width = 6.85, dpi = 300}
mean_se1 <- c("Mean ± Std. Error", "Wilderness Park \nUrban Forest", "47.15 ± 2.17", "1.27 ± 0.36", "137.44 ± 3.71", "5.89 ± 0.77", "12.18 ± 1.65", "37,049.12 ± 2.79", "52.98 ± 1.88", "33.78 ± 1.81", "15.67 ± 1.25")
mean_se2 <- c("Mean ± Std. Error", "UNL City Campus \n Urban Center", "1.58 ± 0.36", "76.52 ± 2.53", "153.39 ± 3.58", "116.90 ± 3.12", "2.97 ± 1.35", "437.03 ± 2.04", "194.42 ± 1.94", "52.46 ± 1.78", "93.03 ± 2.78")
pred_location <- data.frame(mean_se1, mean_se2)
rownames(pred_location) <- c("", " ", "Percent Tree Cover [%]", "Percent Impervious Cover [%]", "Spectral Radiance [Watts/(m² * sr * µm)]", "Artificial Night Sky Radiance [mcd/m²]", "Plant Species Richness", "Patch Area [m²]", "Road Disturbance [vehicles/day/m]", "Highway Disturbance [vehicles/day/m]", "Total Road Length [m]")
names <- rownames(pred_location)
rownames(pred_location) <- seq(1:nrow(pred_location))
pred_location <- cbind(names, pred_location)
colnames(pred_location) <- c(" ", "Mean ± Std. Error", "Mean ± Std. Error")
flextable(pred_location[ ,1:3]) %>% 
  delete_part(part = "header") %>% 
  autofit() %>% 
  merge_h(part = "body") %>% 
  bold(bold = TRUE,i = c("1", "2"), part = "body") %>% 
  hline(i = c("1", "2", "11"), part = "body", border = officer::fp_border(width = 2)) %>% 
  hline_top(part = "body", border = officer::fp_border(width = 2)) %>% 
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  set_caption("") %>% 
  save_as_image(path = here::here("manuscript/figures/pred_location.png"))
```

### Predictor Stats Table

```{r pred_table}
pred_table <- read.table(file = "data/pred_table.txt", header = TRUE) # for predictor stats table

pred_table <- pred_table %>% 
  mutate(Variable = factor(Variable),
         Variable = fct_recode(Variable, "Number of Webs" = "NumWebs",
                               "Number of Spiders" = "NumSpiders",
                               "Nearest Neighbor Distance" = "RetreatDist",
                               "Web Height" = "RetreatHeight"),
         Predictor = factor(Predictor),
         Predictor = fct_recode(Predictor, "Plant Species Richness" = "plant",
                                "Road Disturbance" = "tdr",
                                "Highway Disturbance" = "tdh",
                                "Patch Area" = "patch",
                                "Total Road Length" = "road",
                                "Spectral Radiance" = "spec",
                                "Percent Tree Cover" = "tree",
                                "Proportion Tree Cover" = "tree_frac"),
         org_Estimate = round(org_Estimate, 3),
         bt_Estimate = round(bt_Estimate, 3),
         org_SE = round(org_SE, 3),
         bt_SE = round(bt_SE, 3),
         Z = round(Z, 3),
         P = round(P, 3),
         R = round(R, 3),
         AICc = round(AICc, 3))

pred_table[pred_table == 0] <- ""

pred_table <- pred_table %>% 
  mutate(P = fct_recode(P, "< 0.001 ***" = "0.001",
                        "   0.010 **" = "0.01",
                        "   0.003 **" = "0.003",
                        "   0.004 **" = "0.004",
                        "   0.064 ." = "0.064",
                        "   0.100 ." = "0.1")) %>% 
  dplyr::select(-bt_Estimate, -bt_SE)

colnames(pred_table) <- c('Variable','Model','Predictor', 'Estimate', 'Standard \nError', 'Z-Value', 'P-Value', 'McFadden\'s \nR²', 'AICc \nWeight')

flextable(pred_table[ , 1:9]) %>% 
  autofit() %>% 
  merge_v(j = c('Variable', 'Model', 'McFadden\'s \nR²', 'AICc \nWeight'), part = "body") %>% 
  bold(bold = TRUE, part = "header") %>% 
  hline_bottom(part = "body", border = officer::fp_border(width = 2)) %>% 
  border(j = 'Variable', border.bottom = officer::fp_border(width = 2)) %>% 
  hline(i = c("8", "15", "24"), part = "body", border = officer::fp_border(width = 2)) %>%     
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  valign(valign = "top", part = "all") %>% 
  set_caption("") %>% 
  footnote(i = c(1:3, 5:7, 9:10, 12:14, 16:17, 19:22, 25:26, 28), j = 3, value = as_paragraph(
    c("Predictors that were log-transformed prior to model evaluation. Estimate and standard errors are not back transformed.")), 
    ref_symbols = c("a"), part = "body") %>% 
    footnote(i = 27, j = 3, value = as_paragraph(
    c("Tree cover is assessed as proportion (value from 0 to 1) rather than a percent (values 0 to 100) to avoid model convergence issues.")), 
    ref_symbols = c("b"), part = "body") %>% 
  save_as_image(path = here::here("manuscript/figures/pred_table.png"))
```

## Supplementary Figures and Tables

### Substrate Figures

```{r substrate}
substrates %>% 
  mutate(Location = fct_recode(Location, "Urban Center" = "Campus", "Urban Forest" = "Forest"),
         Location = fct_relevel(Location, "Urban Forest", "Urban Center")) %>% 
  ggplot(aes(x = Location, y = Number, fill = factor(Type, levels=c("Cement", "Metal", "Plastic", "Rocks", "Herb", "Litter", "Shrub", "Tree", "Vine")))) + 
  geom_bar(position = "fill",stat = "identity", alpha=1.0) + 
  scale_y_continuous(labels = scales::percent_format()) + 
  theme(axis.title.x = element_blank()) + 
  xlab("Collection Location") +
  ylab("Percent of Web Substrates") + 
  theme_classic() +
  theme(text = element_text(size = 10)) + 
  scale_fill_manual(values = c("#D94701", "#FD8D3C", "#FDBE85", "#FEEDDE", "#006D2C", "#31A354", "#74C476", "#BAE4B3", "#EDF8E9"), 
                    labels = c("Cement", "Metal", "Plastic", "Rocks", "Herb", "Litter", "Shrub", "Tree", "Vine")) + 
  labs(fill="Substrate Material") + 
  theme(axis.text.x=element_text(colour="black", size=10)) + 
  theme(axis.text.y=element_text(colour="black", size=10)) +
  theme(legend.text=element_text(size=10))
  ggsave("manuscript/figures/substrate_plot.png")
```

### Overall Predictor Plots
```{r predictors_overall}
dist_text <- as_ggplot(text_grob(paste("Search \nDistance \n[log(m)]"), size = 10))
webs_text <- as_ggplot(text_grob(paste("Number of \nWebs \n[log()]"), size = 10))
spiders_text <- as_ggplot(text_grob(paste("Number of \nSpiders \n[log()]"), size = 10))
wd_text <- as_ggplot(text_grob(paste("Nearest \nNeighbor \nDist. [log(cm)]"), size = 10))
wh_text <- as_ggplot(text_grob(paste("Web \nHeight \n[log(cm)]"), size = 10))
plant_text <- as_ggplot(text_grob(paste("Plant Species \nRichness [log()]"), size = 10))
road_text <- as_ggplot(text_grob(paste("Road Disturbance \n[log(vehicles/day/m)]"), size = 10))
highway_text <- as_ggplot(text_grob(paste("Highway Disturbance \n[log(vehicles/day/m)]"), size = 10))
blankPlot <- ggplot()+geom_blank(aes(1,1)) + 
  cowplot::theme_nothing() 
greyPlot <- ggplot()+geom_blank(aes(1,1)) + 
  cowplot::theme_nothing() +
  theme(panel.background = element_rect(fill = "grey", color = "white"))

graphs <- ggarrange(webs_text, webs_plant, webs_tdr, webs_tdh,
           spiders_text, spiders_plant, greyPlot, spiders_tdh,
           wd_text, dist_plant, dist_tdr, greyPlot, 
           wh_text, height_plant, height_tdr, greyPlot, 
          ncol = 4, nrow = 4)

labels <- ggarrange(blankPlot, plant_text, road_text, highway_text, ncol = 4, nrow = 1)

predictors_overall <- ggarrange(graphs, labels, nrow = 2, heights = c(0.8, 0.2))
#saveRDS(predictors_overall, "manuscript/figures/predictors_overall.Rds")
```

## Response Variables by Land Cover Class

```{r land_plots}
land_plots <- ggarrange(search_land_plot, ggarrange(webs_land_plot_nox, spiders_land_plot_nox,dist_land_plot, height_land_plot, labels = c("b", "c", "d", "e"), ncol = 2, nrow = 2, legend = "none", align = "hv"), labels = c("a"), widths = c(0.3, 0.7))

land_plots
#saveRDS(land_plots, "manuscript/figures/land_plots.Rds")
```

## Site Information Table

```{r site_info}
site_info <- site_info %>% 
  mutate(Location = fct_recode(Location, "UNL City Campus - Urban Center" = "Campus", "Wilderness Park - Urban Forest" = "Forest"))
colnames(site_info) <- c("Location", "Site ID", "Date", "Start Latitude", "Start Longitude", "Focal Web Latitude", "Focal Web Longitude", "Search Direction")
flextable(site_info[ ,1:8]) %>% 
  merge_v(j = "Location") %>% 
  autofit(part = "body") %>% 
  hline(i = c("12"), part = "body") %>% 
  bold(bold = TRUE, part = "header") %>% 
  fontsize(size = 10, part = "all") %>% 
  set_caption("") %>% 
  fontsize(size = 10, part = "all") %>% 
  fix_border_issues(part = "all") %>% 
  align(align = "center", part = "all") %>% 
  save_as_image(path = here::here("manuscript/figures/site_info.png"))
```

## Table of Predictor Stats from Model Average

```{r pred_table_avg}
pred_table_avg <- read.table(file = "data/pred_table_avg.txt", header = TRUE) # for predictor stats table

pred_table_avg <- pred_table_avg %>% 
  mutate(Variable = factor(Variable),
         Variable = fct_recode(Variable, "Number of Webs" = "NumWebs",
                               "Nearest Neighbor Distance" = "RetreatDist",
                               "Web Height" = "RetreatHeight"),
         Predictor = factor(Predictor),
         Predictor = fct_recode(Predictor, "Plant Species Richness" = "plant",
                                "Road Disturbance" = "tdr",
                                "Highway Disturbance" = "tdh",
                                "Patch Area" = "patch",
                                "Total Road Length" = "road",
                                "Spectral Radiance" = "spec",
                                "Percent Tree Cover" = "tree",
                                "Proportion Tree Cover" = "tree_frac",
                                "Spectral Radiance" = "spec_scale",
                                "Total Road Length" = "road_scale"),
         Model = factor(Model), 
         Model = fct_recode(Model, "Center " = "Center2"),
         Estimate = round(Estimate, 3),
         SE = round(SE, 3),
         Z = round(Z, 3),
         P = round(P, 3),
         AICc = round(AICc, 3))

pred_table_avg <- pred_table_avg %>% 
  mutate(P = factor(P),
    P = fct_recode(P, "< 0.001 ***" = "0.001",
                        "   0.033 *" = "0.033",
                        "   0.003 **" = "0.003",
                        "   0.043 *" = "0.043",
                        "   0.010 *" = "0.01",
                        "   0.054 ." = "0.054",
                        "   0.228" = "0.228",
                        "   0.005 **" = "0.005",
                        "   0.086 ." = "0.086",
                        "   0.172" = "0.172",
                        "   0.062 ." = "0.062",
                        "   0.299" = "0.299",
                        "   0.377" = "0.377",
                        "   0.120" = "0.12",
                        "   0.241" = "0.241",
                        "   0.172" = "0.172")) 

colnames(pred_table_avg) <- c('Variable','Model','Predictor', 'Estimate', 'Adj. Standard \nError', 'Z-Value', 'P-Value', 'AICc \nWeight')

#saveRDS(pred_table_avg, file = "manuscript/figures/pred_table_avg.Rds")

flextable(pred_table_avg[ , 1:8]) %>% 
  autofit() %>% 
  merge_v(j = c('Variable', 'Model', 'AICc \nWeight'), part = "body") %>% 
  bold(bold = TRUE, part = "header") %>% 
  hline_bottom(part = "body", border = officer::fp_border(width = 2)) %>% 
  border(j = 'Variable', border.bottom = officer::fp_border(width = 2)) %>% 
  hline(i = c("4", "8"), part = "body", border = officer::fp_border(width = 2)) %>%   
  fix_border_issues(part = "all") %>% 
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  valign(valign = "top", part = "all") %>% 
  set_caption("") %>% 
  footnote(i = c(1:3, 5:6, 9:11, 13:16, 18:19), j = 3, value = as_paragraph(
    c("Predictors that were log-transformed prior to model evaluation. Estimate and standard errors are not back transformed.")), 
    ref_symbols = c("a"), part = "body") %>% 
    footnote(i = 12, j = 3, value = as_paragraph(
    c("Tree cover is assessed as proportion (value from 0 to 1) rather than a percent (values 0 to 100) to avoid model convergence issues.")), 
    ref_symbols = c("b"), part = "body") %>% 
  footnote(i = c(17, 20), j = 3, value = as_paragraph(
    c("Predictors were scaled (each value divided by the standard deviation) prior to model evaluation. Estimate and standard errors are not back transformed.")), 
    ref_symbols = c("c"), part = "body")  %>% 
  save_as_image(path = here::here("manuscript/figures/pred_table_avg.png"))
```

## Table of Land Stats

```{r land_stats}
Variable <- c("Search Distance", "Number of Webs", "Number of Spiders", "Neares Neighbor Distance", "Web Height")
Chi <- c(340.32, 106.67, 31.65, 3629.30, 10.496)
df <- c("4, 21", "4, 21", "4, 21", "4, 20", "4, 130")
P <- c("< 0.001 ***", "< 0.001 ***", "< 0.001 ***", "< 0.001 ***", "  0.033 *")
land_stats <- data.frame(Variable, Chi, df, P)
colnames(land_stats) <- c('Variable','Likelihood Ratio \nChi-Squared','Degrees of Freedom', 'P-Value')

flextable(land_stats[ , 1:4]) %>% 
  autofit() %>% 
  bold(bold = TRUE, part = "header") %>% 
  fontsize(size = 10, part = "all") %>% 
  align(align = "center", part = "all") %>% 
  valign(valign = "top", part = "all") %>% 
  set_caption("") %>% 
  save_as_image(path = here::here("manuscript/figures/land_stats.png"))
```
